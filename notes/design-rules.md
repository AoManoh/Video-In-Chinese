# 开发文档层次划分

**"自顶向下、逐层细化" (正式确认)**

```
第一层（架构设计）
    ↓ 指导
第二层（模块设计）
    ↓ 指导
第三层（接口实现）
```

1.  **第一层：宏观架构设计 (已完成)**
    *   **产出物**: `notes/Base-Design.md`（项目基石文档：视频翻译服务 V1.0）
    *   **命名规范**: `Base-Design.md`（固定名称）
    *   **作用**: 这是项目的"宪法"，定义了项目的愿景、边界、核心组件、技术栈和高级工作流。**所有后续设计都不得违背此文档**。
    *   **内容范围**:
        *   项目愿景与 MVP 范围
        *   系统架构与设计（架构模式、服务划分）
        *   技术栈选型（语言、框架、中间件、外部 API）
        *   核心业务工作流（高层次流程，18 步）
        *   处理模式（标准模式、AI 配音模式）
        *   已知限制与风险
        *   服务定位与核心职责（Gateway、Task、Processor 等）
        *   接口能力概览（高层次接口，不包含字段定义）
        *   架构约束与架构原则
        *   配置管理（架构级别的配置项清单）
        *   架构决策记录（ADR）
    *   **不包含**:
        *   具体的 API 契约（.api / .proto 文件）
        *   数据结构字段定义（Request/Response 字段表格）
        *   详细逻辑步骤（Key Logic Steps）
        *   错误码清单
        *   流程图（Mermaid）
        *   具体代码实现
        *   详细算法逻辑
        *   具体错误处理逻辑
        *   性能优化细节
    *   **重要说明**：第一层文档已完成冗余清理（v2.0），不再包含第二层内容。所有 API 契约、数据结构、详细逻辑步骤均在第二层文档中定义。
    
2.  **第二层：模块细分设计 (进行中)**
    *   **产出物**: 针对每个微服务的独立设计文档
    *   **命名规范**: `{服务名}-design.md`
        *   `Gateway-design.md`（已存在）
        *   `Task-design.md`（已存在）
        *   `Processor-design.md`（已存在）
        *   `AIAdaptor-design.md`（已存在）
        *   `AudioSeparator-design.md`（已存在）
    *   **内容**:
        *   依托于第一层级架构文档的划分
        *   服务的核心职责与边界（重申）
        *   **完整的 API 契约定义**（`.api` 文件 for `gateway`, `.proto` 文件 for `task` & `processor` & `ai-adaptor` & `audio-separator`）
        *   **核心数据结构定义**（例如，Redis 中存储的任务对象的详细字段）
        *   **关键逻辑步骤**（Key Logic Steps，采用步骤化描述，而非具体代码）
        *   与其他服务的交互时序图
        *   错误码清单
        *   关键配置项定义（环境变量、应用配置）
        *   与第一层文档的对应关系
    *   **作用**: 这是项目的"部门法"，是指导具体编码工作的最直接蓝图。
    *   **核心理念**: 第二层文档的核心是"契约"（.proto/.api 文件）和"蓝图"（关键逻辑步骤）。
    *   **权威性**：⚠️ **最终 API 契约以第二层文档为准**。第一层文档不包含 API 契约细节，仅包含架构原则和高层次概览。

3.  **第三层：代码实现与接口文档 (开发阶段)**
    *   **产出物**:
        *   符合设计文档的 Go/Python 代码（在 Git 仓库中）
        *   自动生成的 Swagger/OpenAPI 文档（来自 `.api` 文件）
        *   自动生成的 gRPC 代码和文档（来自 `.proto` 文件）
        *   **核心实现决策与上下文文档**（`{服务名}-design-detail.md`）
    *   **命名规范**: `{服务名}-design-detail.md`
        *   `Gateway-design-detail.md`（已存在）
        *   `Task-design-detail.md`（已存在）
        *   `Processor-design-detail.md`（已存在）
        *   `AIAdaptor-design-detail.md`（已存在）
        *   `AudioSeparator-design-detail.md`（已存在）
    *   **内容**:
        *   项目结构（仅列出关键文件和目录，附简要职责说明）
        *   **核心实现决策与上下文**（解释"为什么这么写"，而不是"写了什么"）
        *   依赖库清单（及选型原因）
        *   Dockerfile（及构建说明）
        *   测试策略与示例
        *   待实现任务清单
    *   **作用**: 这是最终可运行、可交互的产物。
    *   **核心理念**: 第三层文档的核心是"代码本身"（在 Git 中）和它的"说明书"（在 .md 文件中，解释"为什么这么写"）。

---

# 第二层次文档约束说明

在第二工作开始之前，我先申明以下内容：

1. 开发时请严格根据第一层次的架构文档 `notes/Base-Design.md` 规划进行设计。
2. 注意，当前第一层次架构设计存在冗余问题，但是为了推进进度，所以暂时没有移除多余冗余内容。
3. 在后续我们开始第二层次文档设计时，请注意以下约束内容：

风险 1：过度设计

- 在第二层花费过多时间设计细节
- 追求完美的接口定义，导致迟迟无法进入开发
- 设计了很多"未来可能需要"的功能

- 申明：我们可以保留高扩展性，这有利于我们日后重构、扩展功能。但是不能进行过度设计，在当前阶段过度设计出用不上的内容

风险 2：设计与实现脱节

- 设计时考虑不周，实现时发现接口定义不合理
- 频繁修改接口定义，导致文档与代码不一致
  缓解措施：

```
第二层设计流程：
1. 定义接口（.api / .proto）
2. 使用 goctl 生成代码骨架
3. 编写关键逻辑步骤验证逻辑可行性
4. 发现问题 → 回到步骤 1 调整
5. 确认无误 → 锁定接口，进入第三层
```
风险 3：第二层设计粒度把握不当
风险描述：

- 设计过粗：缺少关键细节，实现时仍需大量决策
- 设计过细：陷入实现细节，失去设计文档的意义

缓解措施：

第二层设计的边界：
应该包含：

- 完整的接口定义（输入输出）
- 关键数据结构（Redis、数据库）
- **关键逻辑步骤**（Key Logic Steps，采用步骤化描述）
- 服务间交互时序图
- 错误码清单

不应该包含：

- 具体的 Go 代码实现，这部分内容应该下放到第三层次文档实现
- 详细的错误处理逻辑（try-catch）
- 具体的第三方库选择（如 JSON 解析库）
- 性能优化细节（如缓存策略）

示例对比：

```go
错误：过细（陷入实现）
function uploadTaskLogic(req):
    file, err := req.FormFile("video")
    if err != nil {
        return nil, fmt.Errorf("parse file error: %w", err)
    }
    defer file.Close()
    // ... 50 行具体代码

正确：适当粒度（关键逻辑步骤）
function uploadTaskLogic(req):
    1. 解析上传文件
    2. 检查磁盘空间（可用空间 < 文件大小 * 3 + 500MB → 返回 507）
    3. 生成 task_id
    4. 保存文件到 ./data/videos/{task_id}/original.mp4
    5. 创建任务记录到 Redis（状态：PENDING）
    6. 调用 task.CreateTask gRPC
    7. 返回 task_id
```

**关键逻辑步骤的粒度规则**：
- 每个步骤是一个明确的业务动作
- 步骤中可以包含关键判断条件和数据流向
- 如果某个步骤内部逻辑复杂，在第三层文档的"核心实现决策"中解释

**风险补充内容**:

- **应该包含**:
	- **关键配置项定义**: 明确指出该模块需要哪些**环境变量**或**应用配置**来驱动。例如，在设计processor服务时，我们应该明确定义PROCESSOR_MAX_CONCURRENCY这个配置项，它的类型、默认值和作用。

- **为什么需要这个补充？**
	- **设计即文档**: 这能让开发者在编码之前，就清晰地知道他需要依赖哪些外部配置，避免在代码中创造"魔法变量"。
	- **方便运维和部署**: 这也为最终的部署文档（如.env.example文件）提供了直接的输入，确保了从设计到部署的一致性。

---

# 第三层文档代码片段使用规则

在第三层文档（`{服务名}-design-detail.md`）的"核心实现决策与上下文"章节中，可以包含代码片段，但必须遵循以下严格规则：

## 1. 使用目的

代码片段的唯一目的是**阐明决策**，而不是为了被复制粘贴到实际代码中。

- ✅ 正确用途：解释"为什么选择这种算法"、"为什么这样处理错误"
- ❌ 错误用途：提供可直接复制的代码模板

## 2. 篇幅限制

每个代码片段**严格限制在 20 行以内**。

- 如果需要更多行数，说明应该拆分为多个独立的决策点
- 如果无法拆分，说明这个决策过于复杂，应该在代码注释中详细说明

## 3. 形式要求

优先级顺序：

1. **伪代码**（最优先）：用自然语言描述算法逻辑
2. **高度简化的示例代码**（次优先）：仅保留核心逻辑，省略错误处理、日志等细节
3. **实际代码片段**（最后选择）：仅在前两者都无法清晰表达时使用

## 4. 前置条件

只有在以下情况下才可使用代码片段：

- 代码注释和文字描述都难以清晰表达核心思想
- 算法逻辑复杂，需要通过代码结构来说明
- 涉及特定的库或 API 调用方式

## 5. 示例对比

### ❌ 错误示例（过于详细，像是可复制的代码）

```go
// 时长对齐算法实现
func alignDuration(inputFile string, targetDuration float64) (string, error) {
    outputFile := filepath.Join(os.TempDir(), "aligned.mp3")

    // 获取当前时长
    cmd := exec.Command("ffprobe", "-v", "error", "-show_entries",
        "format=duration", "-of", "default=noprint_wrappers=1:nokey=1", inputFile)
    output, err := cmd.Output()
    if err != nil {
        return "", fmt.Errorf("failed to get duration: %w", err)
    }

    currentDuration, err := strconv.ParseFloat(strings.TrimSpace(string(output)), 64)
    if err != nil {
        return "", fmt.Errorf("failed to parse duration: %w", err)
    }

    diff := targetDuration - currentDuration

    // ... 更多实现细节
}
```

### ✅ 正确示例（伪代码，专注于决策）

```
时长对齐算法决策:

我们采用了一种混合策略来处理时长差异。首先，我们计算出时长差 diff。

决策 1 (静音填充): 如果 diff 为正（中文更短），我们优先采用前后均匀填充静音（diff/2）的方式，
因为这能最大程度保留自然的语速。

决策 2 (语速加速): 如果 diff 为负（中文更长），我们采用 ffmpeg 的 atempo 滤镜进行语速加速，
但加速比率严格控制在 1.2 倍以内，以防止声音失真。

决策 3 (截断): 如果加速后仍然超长，作为 MVP 阶段的最终降级策略，我们将截断音频以强制匹配时长，
并记录一条 WARN 级别的日志。
```

---

# 文档设计工作流程

## 1. 工作前审视流程

在开始任何文档设计或更新工作之前，必须执行以下审视流程：

### 1.1 回顾上级文档

- **第二层文档设计前**：完整阅读 `notes/Base-Design.md`，确保理解宏观架构
- **第三层文档设计前**：完整阅读对应的第二层文档（如 `Processor-design.md`），确保理解接口契约和逻辑步骤
- **代码开发前**：完整阅读对应的第三层文档（如 `Processor-design-detail.md`），确保理解实现决策

### 1.2 确保方向一致

- 检查上级文档的版本号和更新日期
- 确认上级文档的核心设计决策
- 确认服务边界和职责划分
- 确认接口定义和数据结构

### 1.3 总体说明更新计划

在开始工作前，必须提供总体说明，包括：

- **更新目标**：本次更新的核心目标是什么？
- **主要变更**：将进行哪些主要变更？
- **与现有文档的差异**：与上级文档或现有文档的主要差异是什么？
- **更新计划**：将按照什么顺序执行更新？

**示例**：
```
更新前总体说明：

本次更新目标：创建 Processor-design.md（第二层文档）

主要变更：
1. 定义 Processor 服务的 gRPC 接口（ProcessVideo）
2. 定义 18 步处理流程的关键逻辑步骤
3. 定义内部结构（logic、composer、mediautil）
4. 定义错误码和配置项

与 Base-Design.md 的对应关系：
- 对应 Base-Design.md 的"1.5 核心业务工作流"
- 对应 Base-Design.md 的"1.4 项目工程结构"中的 server/mcp/processor/

更新计划：
1. 定义服务定位与核心职责
2. 定义 gRPC 接口（.proto 文件）
3. 定义关键逻辑步骤
4. 定义错误码和配置项
```

---

## 2. 工作后审查流程

在完成任何文档设计或更新工作后，必须执行以下审查流程：

### 2.1 批判性审核

以批判性的眼光审核文档内容，提出以下问题：

- **完整性**：是否覆盖了所有必要的章节？
- **准确性**：是否与上级文档一致？是否有逻辑错误？
- **清晰性**：是否易于理解？是否有歧义？
- **可执行性**：第二层的逻辑步骤是否可以直接转化为第三层代码？

### 2.2 检查层次分明

- **第一层文档**：是否只描述"做什么"，不描述"怎么做"？
- **第二层文档**：是否使用"关键逻辑步骤"而非具体代码？
- **第三层文档**：是否专注于"为什么这么写"，而不是"写了什么"？

### 2.3 检查内容准确性

- **接口定义**：第二层的接口定义是否与第三层代码实现一致？
- **数据结构**：各层文档中的数据结构定义是否一致？
- **配置项**：各层文档中的配置项定义是否一致？
- **错误码**：各层文档中的错误码定义是否一致？

### 2.4 总体说明更新差异

在完成工作后，必须提供总体说明，包括：

- **更新内容总结**：本次更新了哪些内容？
- **主要变更点**：与之前版本的主要差异是什么？
- **遗留问题**：是否有待解决的问题？
- **后续工作**：下一步需要做什么？

**示例**：
```
更新后总体说明：

更新内容总结：
1. 已创建 Processor-design.md（第二层文档）
2. 已定义 gRPC 接口（ProcessVideo）
3. 已定义 18 步处理流程的关键逻辑步骤
4. 已定义内部结构（logic、composer、mediautil）
5. 已定义错误码和配置项

主要变更点：
- 新增 composer 包的接口定义（未来可拆分为 gRPC 服务）
- 明确音色管理在 ai-adaptor 中实现，Processor 无感知

遗留问题：
- AI 服务调用的具体实现细节待第三层文档补充

后续工作：
- 创建 Processor-design-detail.md（第三层文档）
- 实现 composer 包的具体代码
```

---

## 3. 第二层文档评审会议流程

第二层文档完成后，必须发起评审会议，确保设计质量。

### 3.1 发起评审

负责人在完成第二层文档后，必须在对话中发起评审：

**示例**：
```
伙伴，Processor-design.md 初稿已完成，发起评审。

根据 REVIEW-CHECKLIST.md，我已确认：
[x] 与第一层文档（Base-Design.md v1.2）一致
[x] 使用关键逻辑步骤而非具体代码
[x] 包含完整接口定义（.proto 文件）
[x] 包含时序图
[x] 包含错误码清单
[x] 包含配置项定义

请您审查。
```

### 3.2 辩证性评估

项目发起者和负责人一起进行辩证性评估：

- **接口设计是否合理**？
- **逻辑步骤是否完整**？
- **是否有遗漏的边界情况**？
- **是否有过度设计**？

### 3.3 达成共识

评审通过后，锁定第二层文档，进入第三层开发。

---

# 文档回溯更新规则

在代码开发过程中，如果发现第二层或第三层文档的设计有问题，必须遵循以下规则：

## 1. 破坏性变更

### 1.1 判断标准

以下变更属于**破坏性变更**，必须发起紧急评审：

- **API 接口签名变更**：输入输出参数的增删改
- **gRPC Proto 定义变更**：message 或 service 的变更
- **核心数据结构变更**：Redis、数据库中的数据结构变更
- **服务间交互协议变更**：调用方式、调用顺序的变更
- **错误码定义变更**：错误码的增删改

### 1.2 处理流程

1. **暂停开发**：立即停止当前的代码开发工作
2. **发起紧急辩论评审**：在对话中说明问题和建议的变更方案
3. **达成新共识**：与项目发起者一起辩证性评估，达成新的设计共识
4. **更新文档**：由项目发起者更新第二层文档，并提交版本控制
5. **继续开发**：基于新的设计继续开发

**示例**：
```
伙伴，我在实现 Processor 的 ProcessVideo 接口时，发现一个问题：

当前设计中，ProcessVideo 接口只接收 task_id 和 original_file_key，
但是在实现时，我发现还需要传递用户的配置选项（如 audio_separation_enabled）。

建议变更：
在 ProcessVideoRequest 中增加 config 字段，类型为 ProcessConfig。

这是一个破坏性变更（API 接口签名变更），请求发起紧急评审。
```

---

## 2. 非破坏性优化

### 2.1 判断标准

以下变更属于**非破坏性优化**，可以直接实现：

- **内部算法优化**：不影响接口的算法改进
- **性能优化**：缓存策略、并发优化等
- **日志增强**：增加日志输出
- **错误处理细化**：更详细的错误信息
- **代码重构**：不影响接口的代码结构调整

### 2.2 处理流程

1. **直接优化**：在代码中直接实现优化
2. **代码提交时提供第三层文档更新说明**：在提交代码时，一并提供对第三层文档的更新说明
3. **由项目发起者一并提交**：项目发起者审查后，一并提交代码和文档

**示例**：
```
代码提交说明：

优化内容：
- 优化了音频时长对齐算法，采用混合策略（静音填充 + 语速加速）

第三层文档更新说明：
在 Processor-design-detail.md 的"核心实现决策与上下文"章节中，
增加"时长对齐算法决策"小节，说明混合策略的选择理由。

这是一个非破坏性优化，不影响接口定义。
```

---

# 文档命名规范总结

## 第一层文档（宏观架构）

**命名规范**: `Base-Design.md`（固定名称）

**产出物**:
- `notes/Base-Design.md`

## 第二层文档（模块设计）

**命名规范**: `{服务名}-design.md`

**产出物**:
- `notes/Gateway-design.md`（已存在，需更新）
- `notes/Task-design.md`（已存在）
- `notes/Processor-design.md`（已存在，需更新）
- `notes/AudioSeparator-design.md`（待创建）

## 第三层文档（代码实现）

**命名规范**: `{服务名}-design-detail.md`

**产出物**:
- `notes/Gateway-design-detail.md`（已存在）
- `notes/Task-design-detail.md`（已存在）
- `notes/Processor-design-detail.md`（已存在）
- `notes/AudioSeparator-design-detail.md`（待创建）

---

# 架构决策记录（ADR）

**命名规范**: `架构决策记录.md`（固定名称）

**产出物**:
- `notes/架构决策记录.md`

**内容**:
- ADR-001 ~ ADR-011（已完成）
- 未来新增的 ADR

---

# 待创建文档清单

## 第二层文档（待创建）

1. `notes/AudioSeparator-design.md`
   - 服务定位与核心职责
   - gRPC 接口定义（.proto 文件）
   - 核心数据结构
   - 关键逻辑伪代码
   - 错误码清单
   - 配置项定义

## 第二层文档（待更新）

1. `notes/Gateway-design.md`
   - 更新 API 定义（新增字段：audio_separation_enabled、polishing_custom_prompt、polishing_video_type、translation_video_type、voice_cloning_auto_select_reference）

2. `notes/Processor-design.md`
   - 更新详细步骤（18 步流程）
   - 新增音频分离步骤
   - 新增说话人日志步骤
   - 新增音频拼接、时长对齐、音频合成步骤

## 第三层文档（待创建）

1. `notes/AudioSeparator-design-detail.md`
   - Python 代码实现
   - gRPC 服务实现
   - Spleeter 模型集成
   - Docker 镜像构建

---

# 文档模板

## 第二层文档模板

第二层文档必须包含以下章节：

### 1. 服务定位与核心职责

- 服务的核心定位
- 核心职责列表
- 服务边界说明（负责什么、不负责什么）

### 2. gRPC/API 接口定义

- **核心产出物**：.proto 或 .api 文件的完整内容
- 必须包含所有接口的输入输出定义
- 必须包含注释说明

### 3. 核心数据结构

- Redis 中的 Hash 结构
- 数据库表结构（如有）
- 关键的内存数据结构

### 4. 关键逻辑步骤（Key Logic Steps）

- 采用步骤化描述，而非具体代码
- 每个步骤是一个明确的业务动作
- 包含关键判断条件和数据流向
- 复杂步骤的内部实现在第三层文档解释

**示例**：
```
步骤 11: 时长对齐 (Duration Alignment)
输入: 完整的中文人声音频, 原始英文片段时长
期望输出: 一段新的、与原始时长完全匹配的中文人声音频
```

### 5. 服务交互时序图

- 使用 Mermaid 格式
- 清晰展示服务间的交互顺序
- 包含关键的数据流向

### 6. 错误码清单

- 列出所有可能的错误码
- 说明错误码的含义和处理建议

### 7. 配置项定义

- 环境变量（.env 文件）
- 应用配置（Redis 中的配置）
- 说明配置项的类型、默认值和作用

### 8. 与第一层文档的对应关系

- 说明本文档对应 Base-Design.md 的哪些章节
- 说明本文档如何细化第一层文档的设计

---

## 第三层文档模板

第三层文档必须包含以下章节：

### 1. 项目结构

- 仅列出关键文件和目录
- 附简要职责说明
- 不需要列出所有文件（避免维护负担）

**示例**：
```
server/mcp/processor/
├── main.go                         # gRPC 服务入口
├── internal/
│   ├── logic/
│   │   └── processor_logic.go      # 主流程编排逻辑
│   ├── composer/                    # 音频合成包
│   └── mediautil/                   # 媒体工具包
└── proto/
    └── processor.proto              # gRPC 接口定义
```

### 2. 核心实现决策与上下文（Core Implementation Rationale）

- **核心理念**：解释"为什么这么写"，而不是"写了什么"
- 说明算法选择理由
- 说明库选择理由
- 说明性能优化决策
- 说明错误处理策略

**代码片段使用规则**：
- **目的**：仅用于阐明决策，不是为了被复制粘贴
- **篇幅**：严格限制在 20 行以内
- **形式**：优先使用伪代码，其次才是高度简化的示例代码
- **前置条件**：必须是在代码注释和文字都难以清晰表达其核心思想时才可使用

**示例**：
```
时长对齐算法决策:

我们采用了一种混合策略来处理时长差异。首先，我们计算出时长差 diff。

决策 1 (静音填充): 如果 diff 为正（中文更短），我们优先采用前后均匀填充静音（diff/2）的方式，
因为这能最大程度保留自然的语速。

决策 2 (语速加速): 如果 diff 为负（中文更长），我们采用 ffmpeg 的 atempo 滤镜进行语速加速，
但加速比率严格控制在 1.2 倍以内，以防止声音失真。

决策 3 (截断): 如果加速后仍然超长，作为 MVP 阶段的最终降级策略，我们将截断音频以强制匹配时长，
并记录一条 WARN 级别的日志。
```

### 3. 依赖库清单（及选型原因）

- 列出所有第三方依赖
- 说明选择该库的原因
- 说明版本要求

### 4. Dockerfile（及构建说明）

- 提供完整的 Dockerfile
- 说明构建步骤
- 说明运行要求

### 5. 测试策略与示例

- 说明测试策略（单元测试、集成测试）
- 提供测试示例
- 说明测试覆盖率要求

### 6. 待实现任务清单（TODO List）

- 列出待实现的功能
- 列出已知的技术债务
- 列出未来的优化方向

---

# 文档更新原则

1. **第一层文档（Base-Design.md）**:
   - 只描述"做什么"，不描述"怎么做"
   - 无具体代码实现
   - 无详细算法逻辑
   - 详细实现均引用第二层文档和 ADR
   - 为后续设计提供清晰的边界和方向

2. **第二层文档（{服务名}-design.md）**:
   - 完整的 API 契约定义（.proto/.api 文件）
   - 核心数据结构定义
   - **关键逻辑步骤**（Key Logic Steps，而非具体代码）
   - 服务间交互时序图
   - 错误码清单
   - 配置项定义
   - 与第一层文档的对应关系

3. **第三层文档（{服务名}-design-detail.md）**:
   - 项目结构（仅列出关键文件和目录）
   - **核心实现决策与上下文**（解释"为什么这么写"）
   - 依赖库清单（及选型原因）
   - Dockerfile（及构建说明）
   - 测试策略与示例
   - 待实现任务清单

4. **架构决策记录（架构决策记录.md）**:
   - 记录所有重要的架构决策
   - 包含背景、考虑的方案、最终决策、决策理由
   - 为未来重构提供参考

---

