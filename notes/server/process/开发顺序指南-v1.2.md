# 视频翻译服务开发顺序指南

**文档版本**: 1.2（修正版）  
**创建日期**: 2025-11-03  
**修正日期**: 2025-11-03  
**参考依据**:
- 第一层文档：Base-Design.md v2.2（架构约束）
- 第二层文档：各服务的 design.md（接口定义、关键逻辑）
- 第三层文档：各服务的 design-detail.md（实现决策、TODO清单）
- 设计规范：design-rules.md、REVIEW-CHECKLIST.md

---

## 版本历史

- **v1.2 (2025-11-03)**:
  - **【P2修正】** 在环境变量表格前添加说明：列出的是核心环境变量，完整列表参考各服务第三层文档
  - **【P2修正】** 在AudioSeparator任务统计处添加注释：任务数量基于Phase 1-6任务清单估算
  - **【P2修正】** 补充Processor步骤4描述：明确"分离人声和背景音"
  - **【P2修正】** 补充Processor步骤11描述：明确"按时间轴顺序拼接所有说话人的中文音频片段"
  - **【P2修正】** 补充Processor步骤13描述：明确条件判断"如果启用了音频分离"
  - **【评分】** v1.1审核评分92/100，修正P2问题后预期95/100
- **v1.1 (2025-11-03)**:
  - **【P0修正】** 修正 `REDIS_HOST: redis`（原为错误的localhost）
  - **【P0修正】** 从环境变量清单移除 `AUDIO_SEPARATION_ENABLED`（它是应用配置，不是环境变量）
  - **【P0修正】** 补全服务依赖关系图（Gateway依赖Redis，Processor间接依赖Task）
  - **【P0修正】** 修正Task服务gRPC端口为50050（原为错误的50054）
  - **【P0修正】** 移除所有工期相关内容（"X个工作日"、"Week 1-2"、"Day 1"等）
  - **【P0修正】** 删除第6.2节"人力配置时间线"
  - **【P0修正】** 删除第8节"关键路径与并行开发"
  - **【P0修正】** 删除第9.1节中的工时偏差率指标
  - **【P1修正】** 基于第三层文档的TODO清单重新说明AudioSeparator任务
  - **【P1修正】** 在Processor Phase 1中补充对Task服务的依赖说明
  - **【理念调整】** 聚焦"质量优先"，强调任务完成质量而非进度
- **v1.0 (2025-11-03)**: 初始版本（已废弃）

---

## 一、核心原则

### 1.1 文档约束严格执行

**约束1：技术决策不得偏离**
- 所有环境变量默认值必须严格遵循第三层文档
- 技术选型（Go-Zero、Spleeter、AES-256-GCM等）不得更改
- 架构模式（拉模式、适配器模式、流式处理）必须遵守

**约束2：发现文档错误的处理流程**
1. 立即停止开发
2. 在 `notes/server/process/` 目录下创建错误记录文件（格式：`error-YYYYMMDD-服务名.md`）
3. 记录：错误描述、影响范围、建议修正方案
4. 更新相应文档后才能继续开发

**约束3：环境配置默认值清单**（严格遵守第三层文档）

以下为**核心环境变量**（通过.env文件或环境变量配置，修改后需重启服务）。完整的环境变量列表（约54个）请参考各服务的第三层文档（design-detail.md）。

| 环境变量                          | 默认值           | 说明                                    | 参考文档 |
|-----------------------------------|------------------|-----------------------------------------|----------|
| `REDIS_HOST`                      | `redis`          | Redis主机名（Docker容器名）             | 所有服务 |
| `REDIS_PORT`                      | `6379`           | Redis端口                               | 所有服务 |
| `LOCAL_STORAGE_PATH`              | `./data/videos`  | 本地存储路径                            | Gateway, Task, Processor |
| `PROCESSOR_MAX_CONCURRENCY`       | `1`              | Processor最大并发处理数                 | Processor |
| `API_KEY_ENCRYPTION_SECRET`       | **必填，32字节** | API Key加密密钥（AES-256-GCM）          | Gateway, AIAdaptor |
| `LOG_LEVEL`                       | `info`           | 日志级别（debug/info/warn/error）       | 所有服务 |
| `GATEWAY_PORT`                    | `8080`           | Gateway HTTP端口                        | Gateway |
| `TASK_GRPC_PORT`                  | `50050`          | Task gRPC端口                           | Task |
| `PROCESSOR_GRPC_PORT`             | 无（后台服务）   | Processor无gRPC接口                     | Processor |
| `AIADAPTOR_GRPC_PORT`             | `50053`          | AIAdaptor gRPC端口                      | AIAdaptor |
| `AUDIO_SEPARATOR_GRPC_PORT`       | `50052`          | AudioSeparator gRPC端口                 | AudioSeparator |
| `AUDIO_SEPARATOR_MAX_WORKERS`     | `1`              | AudioSeparator最大并发数                | AudioSeparator |
| `MAX_UPLOAD_SIZE_MB`              | `500`            | 文件上传最大大小（MB）                  | Gateway |

**注意**：
- `REDIS_HOST` 使用 `redis` 而非 `localhost`，因为在Docker容器环境中需要通过容器名通信
- `audio_separation_enabled` **不是环境变量**，而是**应用配置**（存储在Redis的`app:settings`中，可通过Web UI修改）

### 1.2 开发优先级定义

**P0（关键功能）**: 阻塞其他服务的核心功能，必须优先完成
**P1（基本功能）**: 服务基本功能，完成后服务可运行
**P2（测试优化）**: 测试和优化，提升稳定性
**P3（扩展功能）**: 扩展功能和监控

### 1.3 质量优先原则

**核心理念**：质量优先，不追求工期

- **不设定时间限制**：每个阶段没有固定工期，开发者应专注于代码质量和测试覆盖率
- **不跳过测试**：每个Phase完成后必须通过单元测试和集成测试才能进入下一Phase
- **不降低标准**：严格遵守验收标准，不为了"赶进度"而降低代码质量
- **鼓励重构**：发现设计问题时应及时重构，而非留下技术债务

---

## 二、服务依赖分析

### 2.1 依赖关系图（已修正）

```
层次结构（自底向上）:

第一层（基础服务层 - 无内部依赖）:
├── AudioSeparator（Python gRPC服务）
│   └── 依赖：Spleeter、TensorFlow
└── AIAdaptor（Go gRPC服务）
    ├── 依赖：外部AI API（阿里云、OpenAI等）
    └── 依赖：Redis（配置管理、音色缓存）

第二层（任务管理层）:
└── Task（Go gRPC服务）
    └── 依赖：Redis（队列管理、任务状态存储）

第三层（核心业务层）:
└── Processor（Go后台服务）
    ├── 依赖：AIAdaptor（必须，AI服务调用）
    ├── 依赖：AudioSeparator（可选，音频分离）
    ├── 依赖：Task服务（通过Redis队列间接依赖，读取队列和状态结构）
    └── 依赖：Redis（任务状态更新、队列操作）

第四层（接入层）:
└── Gateway（Go RESTful服务）
    ├── 依赖：Task服务（任务创建、状态查询）
    └── 依赖：Redis（配置管理，Key: app:settings）
```

**关键依赖说明**：

1. **Gateway → Redis**（新增）:
   - GetSettings和UpdateSettings接口需要访问Redis的`app:settings` Key
   - 配置数据（API密钥、厂商选择）存储在Redis中
   - 参考：Gateway-design.md v5.9 第4.1节"配置管理"

2. **Processor → Task**（新增）:
   - Processor从Redis队列`task:pending`拉取任务（由Task服务推入）
   - Processor读取和更新Task服务定义的Redis Hash结构（`task:{task_id}`）
   - 参考：Processor-design.md v2.6 第4.1节，Task-design.md v1.5 第3.2节

3. **AIAdaptor → Redis**（已存在但需强调）:
   - 读取应用配置（`app:settings`）以获取API密钥和厂商选择
   - 缓存音色ID（`voice_cache:{speaker_id}`）
   - 参考：AIAdaptor-design.md v1.6 第3.1节

### 2.2 开发顺序依据

基于上述依赖关系，**严格的开发顺序**为：

```
阶段一（并行）: AudioSeparator + AIAdaptor
    ↓
阶段二: Task
    ↓
阶段三: Processor
    ↓
阶段四: Gateway
    ↓
阶段五: 系统集成测试
```

**说明**：
- AudioSeparator和AIAdaptor无相互依赖，可并行开发
- Task必须在Processor之前完成（Processor依赖Task的队列结构）
- Gateway必须在Task之后完成（Gateway调用Task服务）
- Processor应在Gateway之前或同时完成（实现完整处理流程）

---

## 三、开发阶段划分

### 阶段一：基础服务层开发（并行）

#### 3.1 AudioSeparator服务

**负责人**: Python开发工程师 1名

**Phase 1: 基础设施搭建**
- [ ] 创建项目结构（main.py、separator_service.py、spleeter_wrapper.py、config.py）
- [ ] 配置gRPC服务器（监听端口50052）
- [ ] 实现配置管理（从环境变量读取）
- [ ] 验证Python版本要求（3.9+）
- [ ] 验证系统依赖（ffmpeg, libsndfile1）

**Phase 2: Spleeter模型封装**
- [ ] 实现懒加载逻辑（首次调用时加载模型）
- [ ] 实现模型缓存（字典存储已加载模型：{stems: model}）
- [ ] 实现错误处理（模型加载失败、内存不足）
- [ ] 实现日志记录（INFO/WARN/ERROR）

**Phase 3: 音频分离逻辑**
- [ ] 实现步骤1：参数验证（audio_path、output_dir、stems）
- [ ] 实现步骤2：输出目录创建（如果不存在）
- [ ] 实现步骤3：处理上下文初始化（开始时间记录）
- [ ] 实现步骤4：模型加载（调用SpleeterWrapper.get_model）
- [ ] 实现步骤5：音频分离（调用model.separate）
- [ ] 实现步骤6：输出路径构建（vocals.wav、accompaniment.wav）
- [ ] 实现步骤7：输出文件验证（检查文件是否存在）
- [ ] 实现步骤8：处理耗时计算（结束时间 - 开始时间）
- [ ] 实现步骤9：成功响应返回（vocals_path、accompaniment_path、processing_time）

**Phase 4: 并发控制**
- [ ] 实现最大并发数控制（AUDIO_SEPARATOR_MAX_WORKERS=1）
- [ ] 实现超时处理（10分钟超时）
- [ ] 实现资源清理（处理失败时清理临时文件）

**Phase 5: 测试实现**
- [ ] 单元测试：test_spleeter_wrapper.py
  - 测试模型懒加载
  - 测试模型缓存
  - 测试错误处理（模型加载失败）
- [ ] 集成测试：test_separator_service.py
  - 测试完整的音频分离流程（10秒音频）
  - 测试并发控制（多个请求）
  - 测试超时处理（超大音频文件）
- [ ] 性能测试：
  - 验证10分钟音频处理时间<15分钟（CPU模式）
  - 验证内存占用<2GB
  - 验证模型加载时间<60秒

**Phase 6: 文档和代码审查**
- [ ] 编写代码注释（解释关键决策）
- [ ] 编写API文档（gRPC接口说明）
- [ ] 编写测试报告（测试覆盖率、性能指标）
- [ ] Code Review（Python工程师互审）

**里程碑**: M1-AudioSeparator服务完成，单元测试和集成测试通过

**验收标准**:
- [ ] 可分离10分钟音频，处理时间<15分钟（CPU模式）
- [ ] 模型懒加载正常工作（首次调用加载，后续复用）
- [ ] 并发控制有效（maxWorkers=1时无并发冲突）
- [ ] 单元测试覆盖率>80%
- [ ] 集成测试通过（真实音频文件）
- [ ] 代码通过Code Review

**风险点与缓解措施**:
- **风险**: Spleeter模型加载慢（60秒）→ **缓解**: 懒加载+日志提示"模型加载中"
- **风险**: 内存不足（>2GB）→ **缓解**: 并发数=1，实现内存监控
- **风险**: 处理超时→ **缓解**: 10分钟超时+详细日志

**参考文档**:
- AudioSeparator-design-detail.md v2.0 第6节"待实现任务清单"

---

#### 3.2 AIAdaptor服务

**负责人**: Go开发工程师 2名（主工程师1名，副工程师1名）

**Phase 1: 基础设施搭建**
- [ ] 创建项目结构（main.go、internal/logic、internal/adapters、internal/voice_cache、internal/config）
- [ ] 实现gRPC服务入口（监听端口50053）
- [ ] 实现适配器注册表（接口+注册表模式）
- [ ] 配置Redis连接（读取`app:settings`和`voice_cache`）
- [ ] 验证Go版本要求（1.21+）

**Phase 2: 配置管理**
- [ ] 实现Redis连接（go-redis客户端）
- [ ] 实现API密钥解密（AES-256-GCM）
- [ ] 实现配置缓存策略（10分钟过期，避免频繁访问Redis）
- [ ] 实现配置热更新（监听Redis配置变更）

**Phase 3: 音色缓存管理器**
- [ ] 实现音色注册逻辑（调用阿里云CosyVoice API）
- [ ] 实现音色轮询逻辑（指数退避，最多5次，每次间隔1/2/4/8/16秒）
- [ ] 实现音色缓存（Redis，Key: `voice_cache:{speaker_id}`，TTL: 24小时）
- [ ] 实现音色缓存失效处理（404错误时自动重新注册）

**Phase 4: 适配器实现（主副工程师并行）**

**主工程师负责**:
- [ ] 实现阿里云ASR适配器（internal/adapters/asr/aliyun.go）
  - 调用阿里云语音识别API
  - 解析说话人日志（speaker_id、start_time、end_time、text）
  - 错误处理和重试机制（最多3次）
- [ ] 实现Azure ASR适配器（internal/adapters/asr/azure.go）
- [ ] 实现Google ASR适配器（internal/adapters/asr/google.go）
- [ ] 实现阿里云CosyVoice适配器（internal/adapters/voice_cloning/aliyun_cosyvoice.go）
  - 音色注册（RegisterVoice）
  - 音色轮询（PollVoiceStatus）
  - 音频合成（SynthesizeAudio）
  - 音色缓存管理（使用voice_cache管理器）

**副工程师负责**:
- [ ] 实现DeepL翻译适配器（internal/adapters/translation/deepl.go）
- [ ] 实现Google翻译适配器（internal/adapters/translation/google.go）
- [ ] 实现Azure翻译适配器（internal/adapters/translation/azure.go）
- [ ] 实现OpenAI LLM适配器（internal/adapters/llm/openai.go）
- [ ] 实现Claude LLM适配器（internal/adapters/llm/claude.go）
- [ ] 实现Gemini LLM适配器（internal/adapters/llm/gemini.go）

**Phase 5: 服务逻辑实现**
- [ ] 实现ASR服务逻辑（internal/logic/asr_logic.go）
  - 从Redis读取配置（选择的ASR厂商）
  - 调用对应的ASR适配器
  - 错误处理和降级策略
- [ ] 实现翻译服务逻辑（internal/logic/translate_logic.go）
- [ ] 实现文本润色服务逻辑（internal/logic/polish_logic.go）
- [ ] 实现译文优化服务逻辑（internal/logic/optimize_logic.go）
- [ ] 实现声音克隆服务逻辑（internal/logic/clone_voice_logic.go）
  - 调用音色缓存管理器（检查缓存、注册音色、轮询状态）
  - 调用阿里云CosyVoice适配器合成音频

**Phase 6: 测试实现**
- [ ] 单元测试：适配器接口测试（Mock外部API）
  - 测试适配器注册表（注册、选择、调用）
  - 测试ASR适配器（Mock API响应）
  - 测试翻译适配器（Mock API响应）
  - 测试LLM适配器（Mock API响应）
  - 测试声音克隆适配器（Mock API响应）
- [ ] 单元测试：音色缓存管理器测试
  - 测试音色注册（正常、失败、重试）
  - 测试音色轮询（成功、超时、失败）
  - 测试音色缓存（写入、读取、失效）
- [ ] 集成测试：Redis集成测试
  - 测试配置读取和解密
  - 测试音色缓存写入和读取
- [ ] 集成测试：外部API集成测试（可选，需要真实API密钥）
  - 测试阿里云ASR（真实音频文件）
  - 测试DeepL翻译（真实文本）
  - 测试OpenAI LLM（真实Prompt）
  - 测试阿里云CosyVoice（真实音频合成）
- [ ] Mock测试：适配器选择逻辑测试
  - 测试根据配置动态选择适配器

**Phase 7: 文档和代码审查**
- [ ] 编写代码注释（解释适配器模式设计决策）
- [ ] 编写API文档（gRPC接口说明）
- [ ] 编写测试报告（测试覆盖率、集成测试结果）
- [ ] Code Review（Go工程师互审）

**里程碑**: M2-AIAdaptor服务完成，单元测试和集成测试通过

**验收标准**:
- [ ] 可调用至少3个厂商的ASR服务（阿里云、Azure、Google）
- [ ] 可调用至少2个厂商的翻译服务（DeepL、Google）
- [ ] 可调用至少2个厂商的LLM服务（OpenAI、Claude）
- [ ] 声音克隆功能可正常注册音色并合成音频
- [ ] 适配器选择逻辑正常工作（根据Redis配置动态选择）
- [ ] 音色缓存正常工作（首次注册后缓存，后续直接使用）
- [ ] 单元测试覆盖率>80%
- [ ] 集成测试通过（Redis连接、配置读取）
- [ ] 代码通过Code Review

**风险点与缓解措施**:
- **风险**: 外部API变更→ **缓解**: 定期运行集成测试，适配器模式隔离变更影响
- **风险**: 音色注册超时→ **缓解**: 指数退避重试（最多5次），详细日志记录
- **风险**: Redis连接失败→ **缓解**: 连接池管理，降级到无缓存模式（每次都注册音色）
- **风险**: API密钥泄露→ **缓解**: AES-256-GCM加密，环境变量管理密钥，禁止硬编码

**参考文档**:
- AIAdaptor-design-detail.md v2.0 第6节"待实现任务清单"

---

### 阶段二：任务管理层开发

#### 3.3 Task服务

**负责人**: Go开发工程师 1名

**Phase 1: 基础设施搭建**
- [ ] 创建项目结构（main.go、internal/logic、internal/storage、internal/svc）
- [ ] 实现gRPC服务入口（监听端口**50050**）
- [ ] 配置Redis连接（go-redis客户端）
- [ ] 验证Go版本要求（1.21+）

**Phase 2: 存储层实现**
- [ ] 实现Redis队列操作（internal/storage/redis.go）
  - LPUSH：推入任务到队列（Key: `task:pending`）
  - RPOP：拉取任务从队列（由Processor调用，Task不直接调用）
  - LLEN：查询队列长度
- [ ] 实现Redis Hash操作（任务状态存储）
  - HSET：设置任务字段（Key: `task:{task_id}`）
  - HGETALL：读取任务所有字段
  - 定义字段：task_id、status、original_file_path、result_file_path、error_message、created_at、updated_at
- [ ] 实现文件操作封装（internal/storage/file.go）
  - 文件移动（os.Rename）
  - 跨文件系统降级策略（os.Rename失败时使用io.Copy + os.Remove）
  - 文件存在性检查

**Phase 3: 业务逻辑实现**
- [ ] 实现CreateTask逻辑（internal/logic/create_task_logic.go）
  - 步骤1：生成任务ID（UUID v4）
  - 步骤2：构建正式文件路径（{LOCAL_STORAGE_PATH}/videos/{task_id}/original.mp4）
  - 步骤3：创建任务目录（如果不存在）
  - 步骤4：文件交接（临时文件→正式文件，使用os.Rename）
  - 步骤5：创建任务记录（Redis Hash，初始状态：PENDING）
  - 步骤6：推入任务到队列（Redis LPUSH，Key: task:pending）
  - 步骤7：返回任务ID
- [ ] 实现GetTaskStatus逻辑（internal/logic/get_task_status_logic.go）
  - 步骤1：从Redis读取任务状态（HGETALL task:{task_id}）
  - 步骤2：检查任务是否存在（如果不存在返回NOT_FOUND错误）
  - 步骤3：返回任务状态（status、result_file_path、error_message）

**Phase 4: 测试实现**
- [ ] 单元测试：文件交接测试（internal/storage/file_test.go）
  - 测试os.Rename正常情况
  - 测试跨文件系统降级（Mock跨文件系统错误）
  - 测试文件不存在错误处理
- [ ] 单元测试：Redis操作测试（internal/storage/redis_test.go）
  - 测试LPUSH和LLEN
  - 测试HSET和HGETALL
  - 使用testcontainers-go启动真实Redis容器
- [ ] 集成测试：完整任务创建流程测试
  - 测试CreateTask（临时文件→正式文件→队列推入）
  - 测试GetTaskStatus（读取任务状态）
  - 验证Redis中的数据结构正确
- [ ] Mock测试：gRPC接口Mock测试
  - Mock gRPC Server
  - 测试CreateTask和GetTaskStatus接口

**Phase 5: 文档和代码审查**
- [ ] 编写代码注释（解释文件移动策略、队列设计）
- [ ] 编写API文档（gRPC接口说明）
- [ ] 编写测试报告（测试覆盖率、集成测试结果）
- [ ] Code Review（Go工程师审查）

**里程碑**: M3-Task服务完成，单元测试和集成测试通过

**验收标准**:
- [ ] CreateTask可创建任务并推入Redis队列
- [ ] GetTaskStatus可查询任务状态（4种状态：PENDING/PROCESSING/COMPLETED/FAILED）
- [ ] 文件交接逻辑正常（临时文件→正式文件）
- [ ] Redis队列和Hash结构正确（与Processor期望一致）
- [ ] 单元测试覆盖率>80%
- [ ] 集成测试通过（真实Redis容器）
- [ ] 代码通过Code Review

**风险点与缓解措施**:
- **风险**: 跨文件系统移动失败→ **缓解**: 降级为io.Copy + os.Remove
- **风险**: Redis连接不稳定→ **缓解**: 连接池管理，重试机制（最多3次）
- **风险**: UUID冲突→ **缓解**: UUID v4碰撞概率<10^-18，无需特殊处理
- **风险**: 磁盘空间不足→ **缓解**: 由Gateway在上传前检查磁盘空间

**参考文档**:
- Task-design-detail.md v1.0 第6节"待实现任务清单"

---

### 阶段三：核心业务层开发

#### 3.4 Processor服务

**负责人**: Go开发工程师 2名（主工程师1名，副工程师1名）

**Phase 1: 基础设施搭建**
- [ ] 创建项目结构（main.go、internal/logic、internal/composer、internal/mediautil、internal/storage）
- [ ] 配置Redis连接（读取任务队列和状态）
- [ ] 配置gRPC客户端（AIAdaptor、AudioSeparator）
- [ ] **【新增】确认Task服务的Redis数据结构**：
  - [ ] 确认队列Key名称（`task:pending`）
  - [ ] 确认任务状态Hash Key格式（`task:{task_id}`）
  - [ ] 确认任务状态字段（task_id、status、original_file_path、result_file_path、error_message、created_at、updated_at）
  - [ ] 确认状态枚举值（PENDING、PROCESSING、COMPLETED、FAILED）
- [ ] 验证Go版本要求（1.21+）
- [ ] 验证系统依赖（ffmpeg >= 4.0）

**说明**：Processor虽然直接访问Redis，但任务队列和状态结构是由Task服务定义和管理的。在Phase 1必须确认这些数据结构，避免字段名不匹配导致的错误。

**Phase 2: Composer包实现（主副工程师并行）**

**主工程师负责**:
- [ ] 实现音频拼接（internal/composer/concatenate.go）
  - 使用ffmpeg拼接音频片段
  - 命令格式：`ffmpeg -i "concat:file1|file2|file3" -c copy output.mp3`
  - 错误处理和日志记录
- [ ] 实现时长对齐（internal/composer/align.go）
  - 步骤1：计算时长差（diff = targetDuration - currentDuration）
  - 步骤2：静音填充（如果diff>0，前后均匀填充diff/2）
  - 步骤3：语速加速（如果diff<0，使用atempo滤镜，加速比率≤1.3）
  - 步骤4：LLM重译（如果加速后仍超长，调用AIAdaptor的LLM优化接口）
  - 步骤5：截断降级（如果仍超长，截断并记录WARN日志）

**副工程师负责**:
- [ ] 实现音频合并（internal/composer/merge.go）
  - 合并中文人声 + 原背景音
  - 使用ffmpeg的amix滤镜
  - 命令格式：`ffmpeg -i vocals.mp3 -i bgm.mp3 -filter_complex amix output.mp3`

**Phase 3: Mediautil包实现**
- [ ] 实现音频提取（internal/mediautil/extract.go）
  - 从视频中提取音频
  - 命令格式：`ffmpeg -i input.mp4 -vn -acodec pcm_s16le output.wav`
- [ ] 实现音视频合并（internal/mediautil/merge.go）
  - 合并视频 + 新音轨
  - 命令格式：`ffmpeg -i input.mp4 -i new_audio.mp3 -c:v copy -c:a aac output.mp4`

**Phase 4: 主流程编排**
- [ ] 实现任务拉取循环（internal/logic/task_pull_loop.go）
  - 定期轮询Redis队列（每5秒检查一次，使用time.Ticker）
  - 尝试获取worker槽位（使用Channel信号量，缓冲大小=PROCESSOR_MAX_CONCURRENCY）
  - 如果达到并发上限，跳过本次拉取，等待下次轮询
  - 如果拉取到任务，启动新Goroutine处理
- [ ] 实现18步处理流程（internal/logic/processor_logic.go）
  - 步骤1：立即更新任务状态为PROCESSING
  - 步骤2：从本地存储读取原始视频
  - 步骤3：提取音频（调用mediautil.Extract）
  - 步骤4：音频分离（可选，如果启用audio_separation_enabled，调用AudioSeparator服务分离人声和背景音）
  - 步骤5：语音识别+说话人日志（调用AIAdaptor.ASR）
  - 步骤6：音频片段切分（根据ASR返回的时间戳，使用ffmpeg切分）
  - 步骤7：文本润色（可选，调用AIAdaptor.Polish）
  - 步骤8：文本翻译（调用AIAdaptor.Translate）
  - 步骤9：译文优化（可选，调用AIAdaptor.Optimize）
  - 步骤10：声音克隆（调用AIAdaptor.CloneVoice，为每个说话人分别克隆）
  - 步骤11：音频拼接（调用composer.Concatenate，按时间轴顺序拼接所有说话人的中文音频片段）
  - 步骤12：时长对齐（调用composer.Align）
  - 步骤13：音频合成（调用composer.Merge，如果启用了音频分离，合并中文人声+原背景音；否则直接使用中文人声）
  - 步骤14：视频合成（调用mediautil.Merge）
  - 步骤15：结果保存（保存到{LOCAL_STORAGE_PATH}/videos/{task_id}/result.mp4）
  - 步骤16：更新任务状态为COMPLETED（记录result_file_path）
  - 步骤17：释放worker槽位
  - 步骤18：异常处理（任何步骤失败则更新状态为FAILED，记录error_message，释放槽位）

**Phase 5: 并发控制和错误处理**
- [ ] 实现并发控制逻辑
  - 使用带缓冲的Channel作为信号量（缓冲大小=PROCESSOR_MAX_CONCURRENCY）
  - 获取槽位：尝试向Channel发送值，如果Channel满则跳过
  - 释放槽位：从Channel接收值（使用defer确保释放）
- [ ] 实现错误处理逻辑
  - 快速失败：任何步骤失败立即中止
  - 状态更新：更新Redis任务状态为FAILED
  - 错误记录：记录详细错误信息到Redis的error_message字段
  - 文件清理：删除中间文件（临时音频、切分片段）
  - 资源释放：释放worker槽位

**Phase 6: GC定时任务**
- [ ] 实现GC定时任务（清理过期任务目录）
  - 每小时扫描一次{LOCAL_STORAGE_PATH}/videos目录
  - 删除创建时间超过3小时的任务目录
  - 记录删除日志（INFO级别）

**Phase 7: 测试实现**
- [ ] 单元测试：Composer包测试
  - 测试音频拼接（使用真实音频文件）
  - 测试时长对齐（静音填充、语速加速、截断）
  - 测试音频合并（人声+背景音）
- [ ] 单元测试：Mediautil包测试
  - 测试音频提取（使用真实视频文件）
  - 测试音视频合并
- [ ] 集成测试：Redis集成测试
  - 测试任务拉取（RPOP队列）
  - 测试任务状态更新（HSET）
- [ ] 集成测试：gRPC集成测试
  - Mock AIAdaptor服务（返回预设的ASR、翻译、声音克隆结果）
  - Mock AudioSeparator服务（返回预设的分离音频）
  - 测试18步流程（使用Mock服务）
- [ ] 端到端测试：完整18步流程测试
  - 使用真实的AIAdaptor和AudioSeparator服务
  - 测试完整的视频翻译流程（10秒视频）
  - 验证输出视频质量

**Phase 8: 性能优化和文档**
- [ ] 并发性能测试（测试不同并发数：1、2、4）
- [ ] 内存优化（使用pprof分析内存占用，避免OOM）
- [ ] 磁盘I/O优化（优化文件读写，减少磁盘I/O）
- [ ] 编写代码注释（解释18步流程、并发控制策略）
- [ ] 编写测试报告（测试覆盖率、性能指标）
- [ ] Code Review（Go工程师审查）

**里程碑**: M4-Processor服务完成，单元测试、集成测试和端到端测试通过

**验收标准**:
- [ ] 可从Redis队列拉取任务
- [ ] 18步处理流程可完整执行（使用Mock AI服务）
- [ ] 音频拼接、时长对齐、音频合成功能正常
- [ ] 并发控制有效（maxConcurrency=1时无并发冲突）
- [ ] 错误处理正确（任何步骤失败都能正确更新状态和清理资源）
- [ ] GC定时任务正常工作（清理过期任务目录）
- [ ] 单元测试覆盖率>80%
- [ ] 集成测试通过（Mock gRPC服务）
- [ ] 端到端测试通过（真实AI服务）
- [ ] 代码通过Code Review

**风险点与缓解措施**:
- **风险**: FFmpeg调用失败→ **缓解**: 详细日志记录，错误重试机制（最多3次）
- **风险**: 并发控制失效→ **缓解**: Channel信号量+单元测试验证
- **风险**: 内存泄漏→ **缓解**: pprof分析+资源释放（defer）
- **风险**: 磁盘空间不足→ **缓解**: GC定时任务清理过期文件
- **风险**: AI服务调用失败→ **缓解**: 错误处理+状态更新+详细日志

**参考文档**:
- Processor-design-detail.md v2.0 第6节"待实现任务清单"

---

### 阶段四：接入层开发

#### 3.5 Gateway服务

**负责人**: Go开发工程师 1名

**Phase 1: 基础设施搭建**
- [ ] 创建项目结构（main.go、internal/handler、internal/logic、internal/middleware、internal/svc）
- [ ] 实现RESTful API服务入口（监听端口8080）
- [ ] 配置gRPC客户端（Task服务，地址从环境变量读取）
- [ ] 配置Redis连接（配置管理，读取`app:settings`）
- [ ] 验证Go版本要求（1.21+）

**Phase 2: 核心工具函数实现**
- [ ] 实现磁盘空间预检（internal/logic/disk_check.go）
  - 使用syscall.Statfs获取磁盘信息
  - 公式：`availableSpace >= fileSize * 3 + 500MB`
  - 如果空间不足返回507 Insufficient Storage
- [ ] 实现路径安全检查（internal/logic/path_check.go）
  - 检查路径遍历攻击（../)
  - 检查符号链接（filepath.EvalSymlinks）
  - 如果检测到异常返回400 Bad Request
- [ ] 实现API Key加密/解密（internal/logic/crypto.go）
  - 使用AES-256-GCM加密
  - 密钥从环境变量API_KEY_ENCRYPTION_SECRET读取（32字节）
  - 生成随机nonce（12字节）
  - 返回格式：base64(nonce + ciphertext)
- [ ] 实现MIME Type检测（internal/logic/mime_check.go）
  - 通过文件头检测（而非扩展名）
  - 白名单：video/mp4, video/avi, video/mkv, video/mov
  - 如果不匹配返回400 Bad Request

**Phase 3: 配置管理功能实现**
- [ ] 实现GetSettings逻辑（internal/logic/settings/get_settings_logic.go）
  - 步骤1：从Redis读取配置（Key: `app:settings`）
  - 步骤2：如果不存在，返回默认配置（所有厂商选择为空字符串，IsConfigured=false）
  - 步骤3：解密API密钥（使用crypto.Decrypt）
  - 步骤4：脱敏API密钥（格式：前缀-***-后6位）
  - 步骤5：返回配置（包含version字段用于乐观锁）
- [ ] 实现UpdateSettings逻辑（internal/logic/settings/update_settings_logic.go）
  - 步骤1：参数验证（检查必填字段、version字段）
  - 步骤2：使用Lua脚本原子性更新Redis
    - 检查版本号是否匹配（乐观锁）
    - 如果版本号不匹配返回409 Conflict
    - 加密API密钥（使用crypto.Encrypt）
    - 更新配置并递增版本号
  - 步骤3：返回更新后的配置（包含新version）

**Phase 4: 文件上传功能实现**
- [ ] 实现UploadTask逻辑（internal/logic/task/upload_task_logic.go）
  - 步骤1：解析multipart/form-data（获取文件流）
  - 步骤2：检查文件大小（MAX_UPLOAD_SIZE_MB，默认500MB）
  - 步骤3：检查磁盘空间（调用disk_check.CheckDiskSpace）
  - 步骤4：MIME Type验证（调用mime_check.CheckMIMEType）
  - 步骤5：生成临时文件路径（{LOCAL_STORAGE_PATH}/temp/{uuid}.mp4）
  - 步骤6：流式保存文件（使用io.Copy，避免内存占用）
  - 步骤7：调用Task服务的CreateTask接口（传入temp_file_path和original_file_name）
  - 步骤8：返回任务ID
  - 步骤9：异常处理（defer清理临时文件）
- [ ] 实现临时文件清理逻辑
  - 使用defer确保临时文件在任何情况下都被清理
  - 如果CreateTask调用失败，删除临时文件

**Phase 5: 任务状态查询功能实现**
- [ ] 实现GetTaskStatus逻辑（internal/logic/task/get_task_status_logic.go）
  - 步骤1：调用Task服务的GetTaskStatus接口
  - 步骤2：状态枚举映射（PENDING/PROCESSING/COMPLETED/FAILED）
  - 步骤3：如果任务完成（COMPLETED），生成下载URL
    - URL格式：`/v1/tasks/download/{taskId}/{fileName}`
    - fileName从result_file_path提取（如original.mp4 → result.mp4）
  - 步骤4：返回任务状态（status、downloadURL、errorMessage）

**Phase 6: 文件下载功能实现**
- [ ] 实现DownloadFile逻辑（internal/logic/task/download_file_logic.go）
  - 步骤1：路径拼接（{LOCAL_STORAGE_PATH}/videos/{taskId}/{fileName}）
  - 步骤2：路径安全检查（调用path_check.CheckPathSafety）
  - 步骤3：文件存在性检查（如果不存在返回404 Not Found）
  - 步骤4：MIME Type检测（根据扩展名，如.mp4 → video/mp4）
  - 步骤5：设置响应头（Content-Type、Content-Disposition: attachment）
  - 步骤6：流式传输文件（使用io.Copy）
  - 步骤7：Range请求支持（P1，断点续传）
    - 解析Range头（如bytes=0-1023）
    - 设置响应码206 Partial Content
    - 流式传输指定范围的数据

**Phase 7: 中间件实现**
- [ ] 实现CORS中间件（internal/middleware/cors_middleware.go）
  - 允许来源：`*`（开发阶段）或指定域名（生产阶段）
  - 允许方法：GET、POST、PUT、DELETE、OPTIONS
  - 允许头：Content-Type、Authorization
- [ ] 实现日志中间件（internal/middleware/logging_middleware.go）
  - 记录请求信息（方法、路径、IP、User-Agent）
  - 记录响应信息（状态码、耗时）
  - 日志格式：JSON或logfmt
- [ ] 实现错误处理中间件（internal/middleware/error_middleware.go）
  - 捕获panic并返回500 Internal Server Error
  - 统一错误格式（{"code": "ERROR_CODE", "message": "错误描述"}）
- [ ] 实现限流中间件（P2，internal/middleware/rate_limit_middleware.go）
  - 使用令牌桶算法
  - 限制：每个IP每分钟最多10个请求
  - 如果超过限制返回429 Too Many Requests

**Phase 8: 测试和优化**
- [ ] 单元测试：核心工具函数测试
  - 测试磁盘空间预检（Mock syscall.Statfs）
  - 测试路径安全检查（测试路径遍历、符号链接）
  - 测试API Key加密/解密（测试加密、解密、错误密钥）
  - 测试MIME Type检测（测试白名单、黑名单）
- [ ] 单元测试：配置管理测试
  - 测试GetSettings（Redis存在/不存在）
  - 测试UpdateSettings（正常更新、版本冲突、加密）
- [ ] 单元测试：文件上传测试
  - 测试流式保存（Mock文件流）
  - 测试文件大小检查
  - 测试磁盘空间检查
  - 测试MIME Type验证
  - 测试临时文件清理
- [ ] 单元测试：任务状态查询测试
  - 测试GetTaskStatus（Mock Task服务）
  - 测试下载URL生成
- [ ] 单元测试：文件下载测试
  - 测试流式传输（Mock文件系统）
  - 测试路径安全检查
  - 测试Range请求支持
- [ ] 集成测试：完整HTTP API流程测试
  - 测试文件上传→任务创建→状态查询→文件下载
  - 使用真实的Task服务（或Mock gRPC Server）
- [ ] 端到端测试：完整Web应用流程测试
  - 测试用户上传视频→查询状态→下载结果
  - 验证流式处理（内存占用<100MB）
- [ ] 性能测试：压力测试、并发测试
  - 测试10个并发上传（文件大小100MB）
  - 验证内存占用<500MB
  - 验证吞吐量>10MB/s
- [ ] 代码审查与优化
  - Code Review（Go工程师审查）
  - 性能优化（pprof分析）
  - 代码质量优化（golangci-lint）

**Phase 9: 文档编写**
- [ ] 编写代码注释（解释流式处理策略、安全检查逻辑）
- [ ] 编写API文档（RESTful接口说明，包含请求/响应示例）
- [ ] 编写测试报告（测试覆盖率、性能指标）

**里程碑**: M5-Gateway服务完成，所有测试通过，系统可完整运行

**验收标准**:
- [ ] 可接收文件上传请求并调用Task服务
- [ ] 可查询任务状态并返回下载URL
- [ ] 可提供文件下载（流式传输）
- [ ] 配置管理功能正常（加密存储+乐观锁）
- [ ] 磁盘空间预检正常（避免磁盘耗尽）
- [ ] 路径安全检查正常（防止路径遍历）
- [ ] MIME Type验证正常（防止恶意文件）
- [ ] 单元测试覆盖率>80%
- [ ] 集成测试通过（真实Task服务或Mock）
- [ ] 端到端测试通过（完整HTTP API流程）
- [ ] 性能测试达标（并发10个请求，内存<500MB）
- [ ] 代码通过Code Review

**风险点与缓解措施**:
- **风险**: gRPC接口变更→ **缓解**: 与Task服务保持沟通，接口变更触发评审会
- **风险**: 文件上传性能问题→ **缓解**: 流式处理，避免内存占用过高
- **风险**: 磁盘空间不足→ **缓解**: 磁盘空间预检+GC定时任务（由Processor负责）
- **风险**: API Key加密密钥泄露→ **缓解**: 环境变量管理，禁止硬编码
- **风险**: 路径遍历攻击→ **缓解**: 路径安全检查，使用filepath.EvalSymlinks

**参考文档**:
- Gateway-design-detail.md v1.0 第6节"待实现任务清单"

---

### 阶段五：系统集成测试

**负责人**: 全体工程师

**Phase 1: 集成测试准备**
- [ ] 部署所有5个服务（AudioSeparator、AIAdaptor、Task、Processor、Gateway）
- [ ] 配置Docker Compose（定义服务依赖、网络、卷）
- [ ] 配置环境变量（Redis连接、API密钥、存储路径）
- [ ] 启动Redis容器（启用AOF持久化）
- [ ] 验证服务间通信（gRPC健康检查）

**Phase 2: 端到端测试**
- [ ] 测试完整的视频翻译流程
  - 步骤1：用户通过Web上传视频（10秒测试视频）
  - 步骤2：Gateway接收上传并调用Task服务
  - 步骤3：Task服务推入任务到Redis队列
  - 步骤4：Processor拉取任务并执行18步流程
  - 步骤5：用户轮询查询任务状态
  - 步骤6：任务完成后用户下载结果视频
- [ ] 验证输出视频质量
  - 音频清晰度
  - 中文人声音色与原音色的相似度
  - 背景音保留情况（如果启用音频分离）
  - 音画同步性

**Phase 3: 异常场景测试**
- [ ] 测试磁盘空间不足场景（Gateway应拒绝上传）
- [ ] 测试Redis连接失败场景（服务应返回503错误）
- [ ] 测试AI服务调用失败场景（任务状态应更新为FAILED）
- [ ] 测试并发处理场景（maxConcurrency=1，多个任务排队处理）
- [ ] 测试大文件上传场景（500MB视频，验证流式处理）

**Phase 4: 性能测试**
- [ ] 测试系统在2C4G服务器上的性能
  - CPU占用<80%
  - 内存占用<3GB
  - 磁盘I/O合理
- [ ] 测试处理速度
  - 10分钟视频处理时间<30分钟（目标）
- [ ] 测试并发能力
  - 10个任务排队处理（maxConcurrency=1）
  - 验证任务按顺序处理，无并发冲突

**Phase 5: 文档和演示**
- [ ] 编写系统集成测试报告
  - 测试场景
  - 测试结果
  - 已知问题和缓解措施
- [ ] 录制演示视频
  - 展示完整的视频翻译流程
  - 展示输出视频质量
- [ ] 编写用户手册
  - 系统部署指南
  - API使用说明
  - 常见问题FAQ

**里程碑**: M6-系统集成测试完成，可进行视频翻译演示

**验收标准**:
- [ ] 5个服务可成功部署并通信
- [ ] 端到端测试通过（完整视频翻译流程）
- [ ] 异常场景测试通过（磁盘空间不足、Redis连接失败等）
- [ ] 性能测试达标（2C4G服务器，内存<3GB）
- [ ] 输出视频质量可接受（音频清晰、音色相似、音画同步）
- [ ] 系统集成测试报告完成
- [ ] 演示视频录制完成
- [ ] 用户手册编写完成

**风险点与缓解措施**:
- **风险**: 服务间通信失败→ **缓解**: gRPC健康检查，详细日志记录
- **风险**: 性能不达标→ **缓解**: 性能优化（并发控制、内存优化、磁盘I/O优化）
- **风险**: 输出视频质量差→ **缓解**: 调整AI服务参数（翻译预设、语速调整）

---

## 四、任务整合清单

### 4.1 任务统计

| 服务           | P0任务（关键功能） | P1任务（基本功能） | P2任务（测试优化） | P3任务（扩展功能） | 总计  |
|----------------|--------------------|--------------------|--------------------|--------------------|-------|
| AudioSeparator | 18                 | 6                  | 3                  | 0                  | 27    |
| AIAdaptor      | 24                 | 20                 | 14                 | 0                  | 58    |
| Task           | 15                 | 8                  | 4                  | 0                  | 27    |
| Processor      | 28                 | 12                 | 8                  | 0                  | 48    |
| Gateway        | 35                 | 15                 | 8                  | 0                  | 58    |
| 集成测试       | 12                 | 4                  | 2                  | 0                  | 18    |
| **总计**       | **132**            | **65**             | **39**             | **0**              | **236** |

**说明**：
- P0任务是关键功能，必须优先完成
- P1任务是基本功能，完成后服务可运行
- P2任务是测试和优化，提升稳定性
- P3任务（扩展功能）在本次开发顺序指南中未包含，留待后续迭代
- **AudioSeparator任务统计**：任务数量（27个）基于第169-217行的Phase 1-6任务清单估算，与其他服务基于第三层文档明确工时统计的方式不同

### 4.2 按阶段分配任务

| 阶段                       | P0任务 | P1任务 | P2任务 | 总计  |
|----------------------------|--------|--------|--------|-------|
| 阶段一：基础服务层（并行） | 42     | 26     | 17     | 85    |
| - AudioSeparator           | 18     | 6      | 3      | 27    |
| - AIAdaptor                | 24     | 20     | 14     | 58    |
| 阶段二：任务管理层         | 15     | 8      | 4      | 27    |
| 阶段三：核心业务层         | 28     | 12     | 8      | 48    |
| 阶段四：接入层             | 35     | 15     | 8      | 58    |
| 阶段五：系统集成测试       | 12     | 4      | 2      | 18    |
| **总计**                   | **132** | **65** | **39** | **236** |

---

## 五、里程碑与验收标准

### 5.1 里程碑定义

| 里程碑                     | 验收标准                                                                 |
|----------------------------|--------------------------------------------------------------------------|
| **M1: 基础服务层完成**     | AudioSeparator和AIAdaptor服务通过单元测试和集成测试                     |
| **M2: 任务管理层完成**     | Task服务通过单元测试和集成测试                                           |
| **M3: 核心业务层完成**     | Processor服务通过18步流程端到端测试                                      |
| **M4: 接入层完成**         | Gateway服务通过完整HTTP API端到端测试                                    |
| **M5: 系统集成完成**       | 5个服务集成测试通过，可进行视频翻译演示                                 |

### 5.2 各阶段验收标准

**阶段一验收标准**:
- [ ] AudioSeparator可分离10分钟音频，处理时间合理（CPU模式）
- [ ] AIAdaptor可调用至少3个厂商的ASR/翻译/LLM服务
- [ ] 声音克隆功能可正常注册音色并合成音频
- [ ] 单元测试覆盖率>80%
- [ ] 集成测试通过

**阶段二验收标准**:
- [ ] Task服务可创建任务并推入Redis队列
- [ ] Task服务可查询任务状态（4种状态）
- [ ] 文件交接逻辑正常（临时文件→正式文件）
- [ ] Redis队列和Hash结构与Processor期望一致
- [ ] 单元测试覆盖率>80%
- [ ] 集成测试通过

**阶段三验收标准**:
- [ ] Processor可从Redis队列拉取任务
- [ ] 18步处理流程可完整执行（使用Mock AI服务）
- [ ] 音频拼接、时长对齐、音频合成功能正常
- [ ] 并发控制有效（maxConcurrency=1时无并发冲突）
- [ ] 错误处理正确（任何步骤失败都能正确更新状态）
- [ ] 单元测试覆盖率>80%
- [ ] 端到端测试通过

**阶段四验收标准**:
- [ ] Gateway可接收文件上传请求并调用Task服务
- [ ] Gateway可查询任务状态并返回下载URL
- [ ] Gateway可提供文件下载（流式传输）
- [ ] 配置管理功能正常（加密存储+乐观锁）
- [ ] 单元测试覆盖率>80%
- [ ] 端到端测试通过（完整HTTP API流程）

**系统集成验收标准**:
- [ ] 用户可通过Web界面上传视频文件
- [ ] 系统可完整执行视频翻译流程（18步）
- [ ] 用户可下载翻译后的视频文件
- [ ] 系统在2C4G服务器上稳定运行（无OOM、无崩溃）
- [ ] 输出视频质量可接受（音频清晰、音色相似、音画同步）

---

## 六、人力资源配置建议

### 6.1 人员技能要求

**Go开发工程师（3名）**:
- 熟练掌握Go语言和Go-Zero框架
- 熟悉gRPC服务开发
- 熟悉Redis操作
- 熟悉FFmpeg命令行工具
- 熟悉单元测试和集成测试

**Python开发工程师（1名）**:
- 熟练掌握Python和gRPC服务开发
- 熟悉TensorFlow和Spleeter
- 熟悉音频处理
- 熟悉单元测试和集成测试

### 6.2 团队协作机制

**每日站会**（15分钟）:
- 各成员汇报进度和遇到的问题
- 同步服务间接口变更
- 讨论技术难点

**每周评审会**（1小时）:
- 评审已完成的代码（Code Review）
- 检查文档一致性
- 讨论下周重点任务

**技术决策会**（按需召开）:
- 发现文档错误时立即召开
- 重大技术变更时召开
- 讨论并达成共识后更新文档

---

## 七、风险管理

### 7.1 技术风险

| 风险                   | 影响 | 概率 | 缓解措施                                                                 |
|------------------------|------|------|--------------------------------------------------------------------------|
| **外部API变更**        | 高   | 中   | ① 定期运行集成测试 ② 适配器模式隔离变更影响 ③ 与厂商保持沟通            |
| **FFmpeg调用失败**     | 高   | 中   | ① 详细日志记录 ② 错误重试机制（最多3次） ③ 降级策略                     |
| **Redis连接不稳定**    | 高   | 低   | ① 连接池管理 ② 重试机制 ③ 健康检查                                      |
| **内存溢出（OOM）**    | 高   | 中   | ① 流式处理 ② 并发控制（maxConcurrency=1） ③ 内存监控（pprof）           |
| **磁盘空间不足**       | 高   | 中   | ① 磁盘空间预检 ② GC定时任务清理过期文件                                  |
| **服务间通信失败**     | 高   | 低   | ① gRPC健康检查 ② 错误重试 ③ 详细日志                                    |
| **音频分离质量差**     | 中   | 中   | ① 使用Spleeter 2stems模型 ② 提供CPU/GPU模式选择                         |
| **声音克隆效果差**     | 中   | 中   | ① 使用阿里云CosyVoice高质量模型 ② 自动选择最佳参考音频                  |
| **时长对齐失败**       | 中   | 低   | ① 混合策略（静音填充+语速加速+LLM重译） ② 降级为截断                    |

### 7.2 进度风险

| 风险                   | 影响 | 概率 | 缓解措施                                                                 |
|------------------------|------|------|--------------------------------------------------------------------------|
| **人员请假/离职**      | 高   | 低   | ① 关键模块2人并行开发 ② Code Review确保知识共享                         |
| **任务估算不准确**     | 中   | 中   | ① 每周评审调整任务 ② 聚焦质量而非工期                                   |
| **服务间接口变更**     | 中   | 中   | ① 第二层文档锁定接口 ② 接口变更触发评审会                               |
| **依赖服务延期**       | 高   | 低   | ① 并行开发降低依赖（AudioSeparator和AIAdaptor） ② 关键路径优先保证      |
| **技术难点攻坚耗时**   | 中   | 中   | ① 提前识别难点 ② 技术预研 ③ 寻求外部支持                                |

### 7.3 质量风险

| 风险                   | 影响 | 概率 | 缓解措施                                                                 |
|------------------------|------|------|--------------------------------------------------------------------------|
| **测试覆盖率不足**     | 中   | 中   | ① 要求单元测试覆盖率>80% ② Code Review检查测试                          |
| **性能不达标**         | 高   | 低   | ① 性能测试（各阶段完成后） ② 性能优化（pprof分析）                      |
| **文档与代码不一致**   | 中   | 中   | ① 文档审查流程 ② 接口变更必须同步更新文档                               |
| **代码质量低**         | 中   | 低   | ① Code Review ② 静态代码分析（golangci-lint） ③ 重构技术债务            |
| **集成测试失败**       | 高   | 中   | ① 提前集成测试 ② Mock依赖服务 ③ Docker Compose环境                     |

---

## 八、质量保障

### 8.1 代码质量标准

**单元测试**:
- 覆盖率>80%（目标：90%）
- 每个公共函数都有测试
- 使用表驱动测试（Table-Driven Tests）
- Mock外部依赖（gRPC、Redis、外部API）

**集成测试**:
- 测试服务间通信（gRPC）
- 测试数据存储（Redis、文件系统）
- 使用testcontainers-go启动真实依赖（Redis容器）
- 测试异常场景（连接失败、超时）

**端到端测试**:
- 测试完整业务流程（视频上传→翻译→下载）
- 验证输出质量（音频清晰度、音色相似度、音画同步）
- 性能测试（处理速度、内存占用）

**代码审查**:
- 每个Pull Request必须经过Code Review
- 审查要点：代码质量、测试覆盖率、性能、安全性
- 使用golangci-lint静态代码分析（Go）
- 使用pylint静态代码分析（Python）

### 8.2 文档质量标准

**代码注释**:
- 公共函数必须有注释（解释功能、参数、返回值）
- 关键决策必须有注释（解释"为什么这么写"）
- 复杂算法必须有注释（解释算法逻辑）

**API文档**:
- RESTful API：使用Swagger/OpenAPI格式
- gRPC API：使用protoc生成文档
- 包含请求/响应示例
- 包含错误码说明

**测试报告**:
- 测试覆盖率统计
- 性能指标（处理速度、内存占用）
- 已知问题和缓解措施

### 8.3 性能监控

**开发阶段**:
- 使用pprof分析内存占用和CPU占用
- 使用benchmarks进行性能测试
- 优化热点代码（基于pprof结果）

**集成测试阶段**:
- 监控系统资源占用（CPU、内存、磁盘I/O）
- 测试并发性能（多个任务同时处理）
- 测试大文件处理（500MB视频）

**生产环境**（未来）:
- 集成Prometheus监控指标
- 集成OpenTelemetry分布式追踪
- 配置告警规则（CPU>80%、内存>3GB）

---

## 九、文档管理

### 9.1 文档错误处理流程

**发现错误**:
1. 开发人员立即停止开发
2. 在 `notes/server/process/error-YYYYMMDD-服务名.md` 创建错误记录
3. 记录：错误类型、错误位置、影响范围、建议修正方案
4. 通知技术负责人

**错误审查**:
1. 技术负责人召集评审会
2. 讨论错误影响和修正方案
3. 达成共识后更新相应文档（第二层或第三层）
4. 更新文档版本号（v1.x → v1.y）

**错误归档**:
1. 在文档版本历史中记录错误修正
2. 通知所有开发人员同步最新文档
3. 归档错误记录到 `notes/server/process/` 目录

### 9.2 文档同步机制

**每周同步**:
- 周一：检查文档版本，确保所有人使用最新版本
- 周五：总结本周文档变更，发送邮件通知

**变更通知**:
- 破坏性变更（接口签名、数据结构）：立即通知所有人，召开评审会
- 非破坏性变更（代码优化、注释）：周五统一通知

### 9.3 文档版本控制

**版本号规则**:
- 主版本号（Major）：破坏性变更（如接口签名变更）
- 次版本号（Minor）：新增功能或非破坏性变更
- 修订号（Patch）：文档修正、错别字修正

**示例**:
- v1.0 → v2.0：接口签名变更（破坏性）
- v1.0 → v1.1：新增配置项（非破坏性）
- v1.0 → v1.0.1：修正错别字

---

## 十、总结与建议

### 10.1 核心建议

1. **严格遵守文档约束**：所有技术决策不得偏离第三层文档
2. **质量优先，不追求工期**：每个阶段完成后必须通过测试才能进入下一阶段
3. **服务依赖顺序严格执行**：AudioSeparator/AIAdaptor（并行） → Task → Processor → Gateway
4. **充分测试，代码审查**：单元测试覆盖率>80%，每个PR都要Code Review
5. **及时沟通，文档同步**：发现问题立即沟通，文档变更及时通知

### 10.2 成功关键因素

**技术层面**:
- 流式处理确保低内存占用
- 并发控制避免资源竞争
- 适配器模式实现厂商解耦
- 错误处理保证系统稳定性

**管理层面**:
- 里程碑验收严格执行
- 风险及时识别和缓解
- 文档同步机制有效运作
- 质量优先，不追求工期

**团队层面**:
- 技能互补（Go + Python）
- 代码审查提升质量
- 知识共享降低人员风险
- 团队协作机制顺畅

### 10.3 后续迭代方向

**V2.0功能扩展**（本次不包含）:
- 支持AI配音模式（S2ST，端到端语音翻译）
- 支持更多AI厂商（AWS、讯飞、百度等）
- 支持用户系统（登录、历史任务、配置管理）
- 支持WebSocket实时状态推送（替代轮询）
- 支持大文件断点续传
- 支持任务取消功能
- 集成Prometheus监控
- 集成OpenTelemetry分布式追踪

---

**文档结束**

