# 架构决策记录 (Architecture Decision Record)

本文档记录视频翻译服务项目中所有重要的架构决策、权衡和理由。每个决策都包含背景、考虑的方案、最终选择及未来迁移路径。

---

## ADR-001: MVP 阶段使用本地文件系统而非对象存储

**状态**: 已采纳
**决策日期**: 2025-10-29
**决策者**: 技术团队

### 背景

在设计文件存储方案时，我们面临两个选择：
1. 使用对象存储（MinIO / AWS S3）
2. 使用本地文件系统 + Volume 挂载

### 考虑的方案

#### 方案 A：使用 MinIO 对象存储

**优点**：
- 服务无状态，符合微服务架构最佳实践
- 支持流式上传/下载，不占用服务器内存
- 自动处理并发访问和文件锁
- 提供签名 URL 机制（安全、有时效性）
- 未来易扩展到云存储（S3 兼容接口）

**缺点**：
- 增加一个额外组件（MinIO 容器）
- 增加资源消耗（约 100-200MB 内存）
- 增加部署复杂度
- 在单用户场景下属于过度设计

#### 方案 B：使用本地文件系统

**优点**：
- 无需额外组件，降低部署门槛
- 实现简单，资源消耗更低
- 符合"单用户自部署"的场景定位
- 所有服务在同一台机器，文件路径传递直接

**缺点**：
- 服务依赖本地文件系统（非无状态）
- 需要手动实现 GC 逻辑
- 需要处理并发访问和文件锁
- 未来扩展到分布式需要重构

### 最终决策

**采用方案 B：本地文件系统 + Storage 接口抽象**

### 决策理由

1. **场景匹配度最高**：
   - 项目定位为"单用户自部署服务"，不需要分布式存储
   - 所有服务在同一台机器，水平扩展不是 MVP 的需求
   - 单用户低并发场景，复杂的对象存储能力用不上

2. **资源成本是硬约束**：
   - 目标服务器配置为 2C2G，资源紧张
   - 节省 100-200MB 内存（MinIO 的消耗），降低部署门槛
   - 这部分资源可以留给 ffmpeg 处理大视频文件

3. **复杂性可控**：
   - GC 策略简单："任务创建 3 小时后强制删除"
   - 单用户场景下，并发控制需求低
   - 实现成本低，开发效率高

4. **未来可扩展**：
   - 代码层面设计 Storage 接口，业务逻辑与存储实现解耦
   - 未来迁移到 MinIO / AWS S3 / 阿里云 OSS 时，只需新增实现类
   - 业务代码无需修改，迁移成本低

### 实现要点

1. **Storage 接口抽象**：
   - 定义统一的 Storage 接口（Upload, Download, Delete, GetDownloadURL）
   - MVP 阶段实现 LocalStorage
   - 所有业务代码只依赖接口，不直接操作文件系统

2. **文件存储结构**：
   - 路径：`./data/videos/{task_id}/original.mp4` 和 `./data/videos/{task_id}/result.mp4`
   - Volume 挂载到宿主机，确保容器重启后文件不丢失

3. **GC 策略**：
   - 定时任务每小时扫描 `./data/videos` 目录
   - 删除创建时间超过 3 小时的任务目录
   - 避免磁盘空间耗尽

4. **流式处理**：
   - 上传和下载都使用 `io.Copy`，避免将整个文件读入内存
   - 在 2C2G 服务器上处理大视频文件时至关重要

5. **资源检查**：
   - Gateway 上传时检查磁盘可用空间
   - 拒绝条件：`availableSpace < (inputFileSize * 3 + 500MB)`
   - 返回 507 Insufficient Storage 错误

### 未来迁移路径

当以下任一条件满足时，应考虑迁移到对象存储：

1. **用户需求变化**：
   - 需要支持多用户部署
   - 需要水平扩展（多个 Processor 实例）
   - 需要将文件存储到云端（降低本地存储成本）

2. **迁移步骤**：
   - 实现 MinioStorage 类（实现 Storage 接口）
   - 修改配置文件，将 `storage.type` 从 `local` 改为 `minio`
   - 通过依赖注入切换实例
   - 业务代码无需任何改动

3. **迁移成本**：
   - 代码改动：仅需新增 MinioStorage 实现类（约 200 行代码）
   - 配置改动：修改 docker-compose.yml，新增 MinIO 容器
   - 数据迁移：可选（旧任务文件可保留在本地，新任务使用 MinIO）

### 相关决策

- ADR-002: 并发控制策略（使用 Channel 信号量而非消息队列）
- ADR-003: API 密钥持久化方案（使用 Redis 而非配置文件）

---

## ADR-002: 并发控制策略

**状态**: 已采纳
**决策日期**: 2025-10-29
**决策者**: 技术团队

### 背景

在 2C2G 服务器上，需要限制同时处理的视频任务数量，避免资源耗尽导致服务崩溃。

### 考虑的方案

#### 方案 A：使用消息队列（RabbitMQ / Redis Stream）

**优点**：
- 成熟的队列管理机制
- 支持持久化、重试、死信队列
- 易于监控队列长度

**缺点**：
- 增加额外组件和资源消耗
- 在单用户场景下过度设计
- 增加部署和维护复杂度

#### 方案 B：使用 Go Channel 信号量

**优点**：
- 无需额外组件，Go 原生支持
- 实现简单，资源消耗极低
- 符合单用户场景需求

**缺点**：
- 需要手动处理任务重试逻辑
- 队列状态不可见（需要额外实现监控）

### 最终决策

**采用方案 B：Go Channel 信号量 + 非阻塞拒绝**

### 决策理由

1. **资源优先**：避免引入额外组件（RabbitMQ 需要 100-200MB 内存）
2. **场景匹配**：单用户低并发，简单的信号量机制足够
3. **实现简单**：Go Channel 是语言原生特性，无需学习成本

### 实现要点

1. **Worker 池设计**：
   - 使用带缓冲的 Channel：`make(chan struct{}, maxConcurrency)`
   - 默认 `maxConcurrency = 1`，用户可通过配置文件调整

2. **非阻塞拒绝策略**：
   - ExecuteTask 收到请求后，使用 `select + default` 非阻塞地尝试获取 worker 槽位
   - 如果获取失败，立即返回 `gRPC codes.ResourceExhausted` 错误
   - task 服务收到错误后，保持任务状态为 PENDING（而不是 PROCESSING）
   - processor 服务内部有后台 Goroutine，定期从 Redis 拉取 PENDING 任务重试

3. **用户体验**：
   - 用户可以连续上传多个任务
   - 前端看到多个任务状态都是 PENDING（排队中）
   - 任务按顺序一个个变成 PROCESSING
   - 体验清晰且符合预期

### 未来优化方向

当以下条件满足时，可考虑引入消息队列：

1. 支持多用户部署，需要更复杂的队列管理
2. 需要任务优先级、延迟执行等高级特性
3. 需要跨服务的任务调度

---

## ADR-003: 应用配置持久化方案

**状态**: 已采纳
**决策日期**: 2025-10-29
**决策者**: 技术团队

### 背景

用户需要配置多个 AI 服务的参数（服务商选择、API 密钥、端点 URL、功能开关等）。这些配置需要持久化存储，以便在容器重启后仍然可用。同时，需要考虑安全性、并发修改冲突、以及容器化部署的特殊性。

注：本 ADR 专注于应用配置（Application Configuration），环境配置（Environment Configuration）的管理策略详见 ADR-006。

### 考虑的方案

#### 方案 A：存储在配置文件中

**优点**：
- 符合传统配置管理习惯
- 易于备份和版本控制

**缺点**：
- 用户通过 Web 修改后，需要写回容器内部文件，破坏容器不可变性
- 容器重启后配置丢失（除非挂载 Volume）
- 并发修改需要处理文件锁

#### 方案 B：存储在 Redis 中

**优点**：
- Redis 已经是必需组件，无需额外资源
- 支持 AOF 持久化，数据可靠性高
- 原子性操作，天然支持并发
- 容器无状态，符合最佳实践

**缺点**：
- 需要额外实现加密逻辑
- 需要处理版本冲突（通过乐观锁解决）

### 最终决策

**采用方案 B：Redis + AES-256-GCM 加密 + 乐观锁**

- **存储位置**: Redis HASH，Key 为 `app:settings`
- **持久化策略**: 启用 Redis AOF（Append Only File）持久化
- **Volume 挂载**: `./data/redis:/data`，确保容器重启后数据不丢失
- **并发控制**: 使用乐观锁（版本号）+ Lua 脚本实现原子更新

### 决策理由

1. **无额外成本**：Redis 已经是架构必需组件
2. **容器无状态**：不修改容器内部文件，符合容器化最佳实践
3. **并发安全**：Lua 脚本原子性 + 乐观锁版本号机制
4. **持久化可靠**：Redis AOF + Volume 挂载
5. **用户体验优先**: 用户可以通过 Web UI 随时修改配置，无需重启服务
6. **单用户场景简化**：单用户自部署场景下，所有任务共享同一套配置，无需会话隔离机制（Session-ID）

### 实现要点

#### 数据结构

```
Key: app:settings (HASH)
Fields:
  - version: 1 (乐观锁版本号)
  - processing_mode: "standard"
  - asr_provider: "待定"
  - asr_api_key: "encrypted_value"
  - polishing_enabled: "true"
  - translation_provider: "待定"
  - voice_cloning_provider: "待定"
  ... (其他配置字段)
```

#### 加密策略

- **算法**: AES-256-GCM
- **密钥来源**: 环境变量 `API_KEY_ENCRYPTION_SECRET`（32 字节随机字符串）
- **服务启动检查**: 如果环境变量不存在，拒绝启动并输出明确错误信息
- **加密范围**: 仅加密 API Key 字段，其他配置明文存储

#### API Key 脱敏策略

- **格式**: `前缀-***-后6位`
- **示例**: `sk-proj-abc123...xyz789` → `sk-proj-***-xyz789`
- **应用场景**: GET /v1/settings 接口返回脱敏后的 API Key
- **更新处理**: 如果客户端提交的是脱敏值（包含 `***`），保持 Redis 中的原值不变

#### 乐观锁机制

1. 客户端读取当前配置和版本号（GET /v1/settings）
2. 客户端修改配置
3. 客户端提交修改时携带版本号（POST /v1/settings）
4. 服务端使用 Lua 脚本原子性检查版本号：
   - 如果版本号一致，更新配置并将版本号加 1
   - 如果版本号不一致，返回 409 Conflict 错误，附带当前版本号，要求客户端重试

#### 配置初始化流程

1. Gateway 服务启动时连接 Redis
2. 检查 `app:settings` 是否存在
3. 如果不存在：
   - 从 .env 读取初始 API Keys（可选，用于首次部署）
   - 写入 Redis，version = 1
   - 如果 .env 中没有 API Keys，写入空值
4. 如果存在：
   - 忽略 .env 中的 API Keys
   - Redis 为唯一配置源

详见架构文档第 2.3 节"关键逻辑流程"。

### 未来优化方向

1. 支持密钥轮换（定期更新加密密钥）
2. 支持多用户隔离（每个用户独立的 API 密钥配置）
3. 支持密钥审计日志（记录密钥修改历史）
4. 支持配置备份和恢复

---


## ADR-004: AI 服务统一接口与适配器模式

**状态**: 已采纳
**决策日期**: 2025-10-29
**决策者**: 技术团队

### 背景

项目需要集成多个 AI 服务厂商（待定），不同厂商的 API 格式、响应结构、错误码、音频格式要求各不相同。如果在业务逻辑中直接调用各厂商 API，会导致代码充斥大量 if-else 判断，难以维护和扩展。

### 考虑的方案

#### 方案 A：直接调用厂商 API

**优点**：
- 实现简单，无需额外抽象层

**缺点**：
- 业务逻辑与厂商强耦合
- 新增厂商需要修改核心代码
- 测试困难，难以 Mock
- 代码充斥 if-else，可读性差

#### 方案 B：统一接口 + 适配器模式

**优点**：
- 业务逻辑与厂商解耦
- 新增厂商只需实现新的 Adapter
- 测试友好，易于 Mock
- 代码清晰，符合开闭原则

**缺点**：
- 需要设计统一接口
- 需要实现多个 Adapter

### 最终决策

**采用方案 B：统一接口 + 适配器模式**

### 服务分类

1. **ASR（语音识别）**: 音频 → 带时间戳的源语言文本
2. **LLM（文本处理）**: 文本润色、译文优化
3. **Translation（文本翻译）**: 源语言文本 → 目标语言文本
4. **Voice Cloning（声音克隆）**: 文本 + 参考音频 → 特定音色的语音
5. **S2ST（端到端语音翻译）**: 源语言音频 → 目标语言音频（V2.0 扩展）
6. **Video Processing（视频处理）**: 视频格式转换、合成（当前使用本地 ffmpeg）

### 实现要点

1. **统一接口定义**:
   - 每个服务类型定义统一的输入输出格式
   - 统一的错误码和错误信息
   - 接口设计遵循最小化原则，只包含必需的方法

2. **厂商适配器**:
   - 每个厂商实现对应的 Adapter
   - Adapter 内部处理：
     - API 请求格式转换
     - 响应格式解析
     - 错误码映射
     - 音频格式转换（如需要）
     - 文本分段处理（如超长度限制）
     - 限流控制（如有并发限制）

3. **用户配置**:
   - 用户在应用配置中选择每个服务使用哪个厂商
   - 配置对应厂商的 API Key 和参数
   - 配置存储在 Redis，支持热更新

4. **兼容性处理**:
   - 时间戳格式统一为秒（float）
   - 音频格式自动转换
   - 文本长度自动分段
   - 错误码统一映射

### 决策理由

1. **可扩展性**: 新增厂商只需实现新的 Adapter，业务代码无需修改
2. **可测试性**: 易于 Mock 统一接口，单元测试更简单
3. **可维护性**: 业务逻辑清晰，不与具体厂商耦合
4. **用户友好**: 用户可自由选择和混搭不同厂商的服务

### 未来扩展

- V2.0 可支持用户自定义 Adapter（通过插件机制）
- 支持多厂商负载均衡（如 ASR 同时使用多个厂商，自动选择响应快的）
- 支持厂商降级策略（主厂商失败时自动切换到备用厂商）

---

## ADR-005: 处理模式选择

**状态**: 已采纳
**决策日期**: 2025-10-29
**决策者**: 技术团队

### 背景

视频翻译有两种主流技术路线：
1. **级联式流程（Cascaded）**: ASR → Translation → TTS，每步独立
2. **端到端 S2ST（Speech-to-Speech Translation）**: 直接音频到音频，保留情感

项目愿景强调"最大程度地保留原说话者的情感、语调和节奏"，需要在两种技术路线之间做出选择。

### 考虑的方案

#### 方案 A：仅支持级联式流程

**优点**：
- 可控性高，每步可独立调整
- 成本灵活，用户可选择性价比高的 API
- 架构简单，易于实现和调试

**缺点**：
- 情感保留较差（约 70%）
- 韵律保留一般（停顿、语速可能不匹配）

#### 方案 B：仅支持 S2ST

**优点**：
- 情感保留优秀（约 90%）
- 韵律保留优秀
- 流程简单

**缺点**：
- 黑盒，翻译质量不可控
- 依赖单一厂商
- 成本较高

#### 方案 C：同时支持两种模式

**优点**：
- 兼顾可控性和情感保留
- 用户可根据场景选择

**缺点**：
- 架构复杂，维护成本高
- 需要实现两套执行路径

### 最终决策

**分阶段实现**：
- **V1.0（MVP）**: 仅支持级联式流程
- **V2.0**: 新增 S2ST 模式，用户可选择

### 决策理由

1. **MVP 优先验证核心架构**:
   - 级联式流程更容易调试和优化
   - 降低对单一厂商的依赖风险
   - 可以充分验证适配器模式的有效性

2. **目标用户需求分析**:
   - 主要场景（个人学习）更看重翻译准确性
   - 次要场景（内容创作）才需要极致情感保留
   - MVP 阶段优先满足主要场景

3. **技术成熟度**:
   - 级联式流程使用的都是成熟 API
   - S2ST 服务（如 ElevenLabs Dubbing）较新，稳定性待验证
   - 等待技术成熟后再引入，降低风险

4. **成本考虑**:
   - 级联式流程成本更低，用户可自由选择 API
   - S2ST 成本较高（约为级联式的 1.5-2 倍），不适合所有用户

### 实现要点

#### V1.0 级联式流程优化

1. 新增"文本润色"步骤，去除口语化表达，修正识别错误
2. 新增"译文优化"步骤，使翻译更自然流畅
3. 使用 Voice Cloning 服务克隆原音色
4. 所有步骤可由用户选择是否启用

#### V2.0 S2ST 模式扩展

1. 新增处理模式选择（标准模式 / AI配音模式）
2. 新增 S2ST Service 适配器（待定厂商）
3. processor 服务根据模式选择不同执行路径
4. 配置管理支持两套配置

### 质量对比

| 维度       | 级联式流程（V1.0） | S2ST 模式（V2.0） |
| ---------- | ------------------ | ----------------- |
| 翻译准确性 | 高（可人工校对）   | 较高（不可校对）  |
| 情感保留   | 约 70%             | 约 90%            |
| 音色克隆   | 较好               | 优秀              |
| 韵律保留   | 一般               | 优秀              |
| 成本       | 较低               | 较高              |
| 可控性     | 高                 | 低（黑盒）        |

### 未来扩展

- V3.0 支持混合模式：级联式流程 + 情感迁移算法
- 支持用户自定义处理流程（拖拽式配置）
- 支持 A/B 测试，对比两种模式的效果

---

## ADR-006: 配置管理策略

**状态**: 已采纳
**决策日期**: 2025-10-29
**决策者**: 技术团队

### 背景

项目需要管理两类配置：
1. **系统资源配置**：如并发数、存储路径、Redis 连接信息
2. **AI 服务配置**：如 API 密钥、服务商选择、端点 URL

这两类配置的变更频率和影响范围不同，需要采用不同的管理策略。

### 配置分类

#### 环境配置（Environment Configuration）

**定义**: 服务启动和运行所必需的基础设施参数，定义服务的"物理边界"和"生存环境"。

**示例**:
- `PROCESSOR_MAX_CONCURRENCY`: 最大并发处理数
- `LOCAL_STORAGE_PATH`: 本地存储路径
- `REDIS_HOST`, `REDIS_PORT`: Redis 连接信息
- `API_KEY_ENCRYPTION_SECRET`: API Key 加密密钥
- `LOG_LEVEL`: 日志级别
- `GATEWAY_PORT`: Gateway 服务端口

**特点**:
- 启动时必需，不存在或不正确则服务无法启动
- 高度稳定，一旦服务启动，极少变动
- 与部署环境强相关，取决于服务器资源

#### 应用配置（Application Configuration）

**定义**: 服务启动后，用于调整其业务行为和逻辑的参数，不影响服务的生死，只影响工作方式。

**示例**:
- AI 服务厂商选择和 API 密钥
- 处理模式选择（标准模式 / AI配音模式）
- 文本润色和译文优化开关
- 服务端点 URL

**特点**:
- 运行时可变，用户可能随时修改
- 与业务逻辑强相关，直接被业务代码使用
- 与部署环境弱相关

### 考虑的方案

#### 方案 A：所有配置都使用 .env 文件

**优点**：
- 符合传统配置管理习惯
- 易于备份和版本控制

**缺点**：
- 用户修改后需要重启服务，体验差
- 修改需要写入容器内部文件，破坏容器不可变性
- 不适合频繁变更的配置

#### 方案 B：所有配置都使用 Redis

**优点**：
- 支持热更新，无需重启
- 容器无状态

**缺点**：
- 环境配置在 Redis 中不合理（如 Redis 连接信息本身）
- 服务启动依赖 Redis，增加启动复杂度

#### 方案 C：混合配置模式

**优点**：
- 环境配置使用 .env，应用配置使用 Redis
- 各取所长，符合配置的变更特性

**缺点**：
- 需要维护两套配置管理逻辑

### 最终决策

**采用方案 C：混合配置模式**

- **环境配置**: 使用 `.env` 文件或环境变量，修改后需重启服务
- **应用配置**: 使用 Redis（Key: `app:settings`），支持热更新

### 决策理由

1. **符合配置变更特性**:
   - 环境配置极少变更，重启服务可接受
   - 应用配置频繁变更，热更新提升用户体验

2. **容器化最佳实践**:
   - 环境配置通过环境变量传入，符合 12-Factor App 原则
   - 应用配置存储在 Redis，容器无状态

3. **用户体验友好**:
   - 常用操作（修改 API Key）零门槛，Web UI 即可完成
   - 高级操作（修改资源限制）明确告知需要重启

4. **安全性**:
   - API Key 加密存储在 Redis
   - 加密密钥通过环境变量传入，不存储在代码中

### 实现要点

#### 环境配置（.env 文件）

```
REDIS_HOST=redis
REDIS_PORT=6379
LOCAL_STORAGE_PATH=./data/videos
PROCESSOR_MAX_CONCURRENCY=1
API_KEY_ENCRYPTION_SECRET=your-32-byte-secret-key
LOG_LEVEL=info
GATEWAY_PORT=8080
```

#### 应用配置（Redis HASH: `app:settings`）

```
HSET app:settings version 1
HSET app:settings processing_mode "standard"
HSET app:settings asr_provider "待定"
HSET app:settings asr_api_key "encrypted_value"
HSET app:settings polishing_enabled "true"
HSET app:settings translation_provider "待定"
...
```

#### 配置初始化流程

1. Gateway 服务启动时连接 Redis
2. 检查 `app:settings` 是否存在
3. 如果不存在：
   - 从 .env 读取初始 API Keys（可选）
   - 写入 Redis，version = 1
   - 如果 .env 中没有 API Keys，写入空值
4. 如果存在：
   - 忽略 .env 中的 API Keys
   - Redis 为唯一配置源

#### API Key 安全策略

1. **加密存储**: 使用 AES-256-GCM 加密，密钥来自环境变量
2. **脱敏返回**: GET /v1/settings 返回脱敏后的 API Key（`前缀-***-后6位`）
3. **乐观锁**: 使用版本号防止并发修改冲突
4. **原子更新**: 使用 Lua 脚本保证原子性

### 未来优化方向

1. 支持密钥轮换（定期更新加密密钥）
2. 支持配置审计日志（记录配置修改历史）
3. 支持配置备份和恢复
4. 支持配置导入导出（JSON 格式）

---

## ADR-007: 声音克隆服务选型

**状态**: 已采纳
**决策日期**: 2025-10-30
**决策者**: 技术团队

### 背景

声音克隆是本项目的核心功能，有两种技术路线：
1. 本地化（GPT-SoVITS）：需要 GPU，部署复杂，完全本地化
2. 云端化（阿里云 CosyVoice）：零硬件门槛，部署简单，需要 API 调用

### 考虑的方案

#### 方案 A：本地化（GPT-SoVITS）

**优点**：
- 完全本地化，无隐私风险
- 无 API 成本
- 声音克隆质量高

**缺点**：
- 需要 GPU（NVIDIA，支持 CUDA）
- 部署复杂（需要 NVIDIA Container Toolkit）
- 资源占用高（需要 4-8GB 显存）
- 违背项目愿景"2C2G 即可"

#### 方案 B：云端化（阿里云 CosyVoice）

**优点**：
- 零硬件门槛，符合"2C2G 即可"愿景
- 部署简单，降低用户门槛
- 扩大用户群体（无 GPU 用户也可使用）
- 声音克隆质量可接受

**缺点**：
- 需要 API 调用成本
- 声音数据上传到云端（隐私风险）

### 最终决策

**V1.0 采用方案 B：云端化（阿里云 CosyVoice）**

### 决策理由

1. **符合项目愿景**："2C2G 即可"（实际为 2C4G，因为引入了音频分离服务）
2. **降低部署门槛**：扩大用户群体，无 GPU 用户也可使用
3. **遵循 MVP 原则**：避免过度设计，快速验证产品可行性
4. **适配器模式已提供扩展性**：V2.0 可扩展本地模式，无需重构现有代码

### 实现要点

1. **服务商选择**：阿里云 CosyVoice
2. **API 调用**：通过适配器模式调用
3. **参考音频选择**：自动从说话人片段中选择质量最好的 3-10 秒音频
4. **多说话人支持**：为每个说话人分别调用 API

### 未来扩展

V2.0 可根据用户需求扩展本地模式（GPT-SoVITS），通过适配器模式实现，无需重构现有代码。

---

## ADR-008: 音频分离方案选型

**状态**: 已采纳
**决策日期**: 2025-10-30
**决策者**: 技术团队

### 背景

为了保留视频的背景音（BGM、环境音），需要分离人声和背景音。这是核心功能，不是扩展功能。

### 考虑的方案

#### 方案 A：不分离背景音，直接替换音轨

**优点**：
- 实现简单
- 无需额外资源

**缺点**：
- 丢失背景音，用户体验差
- 不符合项目愿景"最大程度保留原说话者的情感、语调和节奏"

#### 方案 B：使用 Spleeter（Python 微服务）

**优点**：
- 完全本地化，无隐私风险
- 无 API 成本
- 技术成熟，使用简单
- 质量可接受

**缺点**：
- 需要引入 Python 微服务
- 增加 500MB-1GB 内存占用
- Docker 镜像增加 1.5-2GB

#### 方案 C：使用云端 API

**优点**：
- 无需本地资源

**缺点**：
- 额外 API 成本
- 隐私风险（音频上传到云端）

### 最终决策

**采用方案 B：Spleeter（Python 微服务）**

### 决策理由

1. **核心功能**：保留背景音是基本用户体验，不是扩展功能
2. **资源可接受**：2C4G 服务器可运行（峰值 3-4GB 内存）
3. **技术成熟**：Spleeter 使用简单，维护成本低
4. **完全本地化**：无隐私风险，无 API 成本

### 实现要点

1. **服务名**：audio-separator
2. **技术栈**：Python + gRPC + TensorFlow + Spleeter
3. **Docker 镜像**：约 1.5-2GB
4. **运行时内存**：500MB-1GB
5. **处理速度**：约 30-60 秒 / 3 分钟音频（2C CPU）
6. **模型**：2stems（人声 + 伴奏）

### 未来优化

1. 支持更高质量的分离模型（4stems、5stems）
2. 支持 GPU 加速（可选）
3. 支持用户选择是否启用音频分离

---

## ADR-009: 多说话人场景处理策略

**状态**: 已采纳
**决策日期**: 2025-10-30
**决策者**: 技术团队

### 背景

视频中常态是多人对话（技术视频、访谈、教学视频），必须区分说话人，才能精准克隆每个人的声音。

### 最终决策

**V1.0 必须支持多人场景**

### 决策理由

1. **常态需求**：技术视频、访谈、教学视频常态是多人对话
2. **核心竞争力**：精准克隆每个说话人的声音，提升用户体验
3. **技术可行**：主流 ASR 厂商（阿里云、Azure、Google Cloud）均支持说话人日志

### 实现要点

1. **说话人日志（Speaker Diarization）**：
   - 使用支持说话人日志的 ASR 厂商（阿里云、Azure、Google Cloud）
   - 输出格式：[{speaker_id, start, end, text, audio_segment}, ...]

2. **参考音频选择**：
   - 自动选择：从每个说话人的片段中选择质量最好的 3-10 秒音频
   - 评分标准：时长适中、音量稳定、背景噪音低

3. **声音克隆**：
   - 为每个说话人分别调用 Voice Cloning API
   - 输入：中文文本 + 参考音频
   - 输出：中文音频片段

4. **音频拼接**：
   - 按时间轴顺序拼接所有说话人的音频

### 未来优化

1. 支持用户手动选择参考音频
2. 支持用户手动调整说话人识别结果
3. 支持说话人标签（如"主讲人"、"嘉宾"）

---

## ADR-010: 时长对齐策略

**状态**: 已采纳
**决策日期**: 2025-10-30
**决策者**: 技术团队

### 背景

翻译后的中文音频时长可能与原音频不匹配，需要对齐以确保音画同步。

### 考虑的方案

#### 方案 A：拉伸/压缩音频

**优点**：
- 实现简单

**缺点**：
- 音质下降明显
- 不自然

#### 方案 B：静音填充

**优点**：
- 音质无损
- 符合人类说话习惯（说话前后有停顿）
- 实现简单（FFmpeg 原生支持）

**缺点**：
- 只能处理中文更短的情况

#### 方案 C：混合策略

**优点**：
- 兼顾音质和灵活性

**缺点**：
- 实现稍复杂

### 最终决策

**采用方案 C：混合策略（优先静音填充，必要时加速语速）**

### 决策理由

1. **静音填充比拉伸音频更自然**
2. **符合人类说话习惯**（说话前后有停顿）
3. **实现简单**（FFmpeg 原生支持）
4. **灵活性高**（可处理中文更短和更长的情况）

### 实现策略

1. **中文更短**（diff > 0）：
   - 如果 diff <= 2s：前后填充静音（diff/2）
   - 如果 diff > 2s：前后各填充 1s，剩余通过轻微拉伸视频画面

2. **中文更长**（diff < 0）：
   - 如果 |diff| <= 10%：加速中文语速（atempo 1.1）
   - 如果 |diff| > 10%：
     a. 优先：LLM 重新翻译为更简洁的表达
     b. 备选：加速中文语速（atempo 1.2，最大不超过 1.3）

### 未来优化

1. 支持用户自定义对齐策略
2. 支持更智能的对齐算法（基于语义分段）
3. 支持用户手动调整对齐结果

---

## ADR-011: 说话人日志与 ASR 对齐策略

**状态**: 已采纳
**决策日期**: 2025-10-30
**决策者**: 技术团队

### 背景

市面上很少有 ASR API 能在一个调用中完美地同时完成高精度的 ASR 和说话人日志。通常需要分别调用，然后进行对齐。

### 考虑的方案

#### 方案 A：使用单一 API 同时完成 ASR 和说话人日志

**优点**：
- 实现简单，只需一次 API 调用
- 无需对齐逻辑

**缺点**：
- 市面上支持的 API 很少
- 质量可能不如分离式处理

#### 方案 B：分离式处理 + 时间戳对齐

**优点**：
- 可选择最优的 ASR 和说话人日志服务
- 灵活性高，可根据需求调整

**缺点**：
- 需要实现对齐算法
- 增加开发复杂度

### 最终决策

**采用方案 B：分离式处理 + 时间戳对齐**

但在第一层架构文档中简化描述，只说明期望输入和输出，具体实现留到第二层文档。

### 决策理由

1. **灵活性高**：可选择最优的 ASR 和说话人日志服务
2. **质量可控**：分离式处理通常质量更高
3. **符合第一层文档定位**：只描述"做什么"，不描述"怎么做"

### 实现要点（第二层文档）

1. **分别调用**：
   - 说话人日志 API → [{speaker_id, start, end}, ...]
   - ASR API → [{start, end, text}, ...]

2. **对齐算法**：
   - 计算每个 ASR 文本块与每个说话人片段的时间戳重叠度（IoU）
   - 将文本块分配给重叠度最高的说话人
   - 如果重叠度 < 0.5，标记为"未知说话人"

3. **降级策略**：
   - 如果说话人日志失败，降级为单说话人模式
   - 所有文本块分配给 speaker_0

### 未来优化

1. 支持用户手动调整说话人识别结果
2. 支持更智能的对齐算法（基于语义）
3. 支持说话人标签（如"主讲人"、"嘉宾"）

---


## 决策模板

```markdown
## ADR-XXX: 决策标题

**状态**: 提议中 / 已采纳 / 已废弃
**决策日期**: YYYY-MM-DD
**决策者**: 团队成员

### 背景
描述问题和上下文

### 考虑的方案
列出所有考虑的方案及其优缺点

### 最终决策
说明最终选择的方案

### 决策理由
解释为什么选择这个方案

### 实现要点
关键的实现细节

### 未来迁移路径
什么情况下需要重新评估这个决策
```

