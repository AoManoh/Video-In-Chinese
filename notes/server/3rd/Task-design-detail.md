# Task 服务实现详细设计(第三层)

**文档版本**: 1.0
**创建日期**: 2025-11-03
**关联文档**:
- 第一层：`notes/server/1st/Base-Design.md` v2.2
- 第二层：`notes/server/2nd/Task-design.md` v1.5
- 规范文档：`notes/server/1st/design-rules.md`

---

## 版本历史

- **v1.0 (2025-11-03)**:
  - 初始版本，根据第三层文档工作清单创建
  - 完善核心实现决策与上下文（7个关键决策点）
  - 新增详细的依赖库选型原因
  - 新增完整的测试策略（单元测试、集成测试、端到端测试）
  - 新增详细的待实现任务清单
  - 严格遵循 design-rules.md 规范（代码片段 ≤20行，专注于"为什么"）

---

## 1. 项目结构

```
server/app/task/
├── main.go                          # gRPC 服务入口，启动gRPC服务器
├── internal/
│   ├── config/
│   │   └── config.go                # 配置加载（环境变量、go-zero配置）
│   ├── logic/
│   │   ├── create_task_logic.go     # 创建任务逻辑
│   │   └── get_task_status_logic.go # 查询任务状态逻辑
│   ├── svc/
│   │   └── service_context.go       # 服务上下文（依赖注入）
│   ├── storage/
│   │   ├── redis.go                 # Redis操作封装
│   │   └── file.go                  # 文件操作封装
│   └── types/
│       └── task.go                  # 任务数据结构定义
├── etc/
│   └── task.yaml                    # go-zero配置文件
└── pb/
    ├── task.proto                   # gRPC接口定义
    ├── task.pb.go                   # 自动生成的Protobuf代码
    └── task_grpc.pb.go              # 自动生成的gRPC代码
```

**关键文件职责**:
- `main.go`: 服务启动入口，初始化gRPC服务器、Redis客户端
- `internal/logic/`: 核心业务逻辑，实现第二层文档定义的关键逻辑步骤
- `internal/storage/`: 存储层封装，隔离Redis和文件系统操作
- `internal/svc/service_context.go`: 依赖注入容器，管理Redis客户端等
- `pb/task.proto`: gRPC接口定义文件，使用`protoc`生成代码

---

## 2. 核心实现决策与上下文

> ⚠️ **核心理念**：本章专注于解释"为什么这么写"，而不是"写了什么"。代码片段仅用于阐明决策，严格限制在20行以内，优先使用伪代码。

### 2.1 文件移动策略：为什么使用os.Rename而非io.Copy？

**决策**: 使用`os.Rename`移动文件，而非`io.Copy`复制后删除

**理由**:
1. **性能优势**: `os.Rename`是原子操作，仅修改文件系统元数据，不涉及数据复制
2. **避免磁盘空间浪费**: `io.Copy`需要双倍磁盘空间（临时文件+正式文件），`os.Rename`无此问题
3. **原子性**: `os.Rename`保证文件移动的原子性，避免中间状态
4. **符合架构原则**: 第一层文档要求"文件交接使用移动而非复制"

**性能对比**（1GB文件）:
- `os.Rename`: 耗时 < 1ms，磁盘空间占用 1GB
- `io.Copy + os.Remove`: 耗时 8秒，磁盘空间占用 2GB（复制过程中）

**跨文件系统问题**:
- **问题**: `os.Rename`仅支持同一文件系统内移动，跨文件系统会失败
- **缓解**: 检测`os.Rename`错误，如果是跨文件系统错误，降级为`io.Copy + os.Remove`

**实现要点**（伪代码）:
```go
// 文件移动逻辑
func moveFile(src, dst string) error {
    // 优先使用os.Rename（原子操作）
    err := os.Rename(src, dst)
    if err == nil {
        return nil
    }

    // 如果是跨文件系统错误，降级为io.Copy
    if isCrossDeviceError(err) {
        return copyAndRemove(src, dst)
    }

    return err
}
```

---

### 2.2 任务ID生成策略：为什么使用UUID v4而非雪花算法？

**决策**: 使用UUID v4生成任务ID

**理由**:
1. **全局唯一性**: UUID v4基于随机数，全局唯一性有保证（碰撞概率 < 10^-18）
2. **无需中心化**: 不需要中心化的ID生成服务，避免单点故障
3. **标准化**: UUID是RFC 4122标准，跨语言兼容性好
4. **简单性**: 无需维护额外的ID生成服务，降低系统复杂度

**雪花算法的问题**:
- **时钟依赖**: 依赖系统时钟，时钟回拨会导致ID重复
- **中心化**: 需要维护机器ID，增加运维复杂度
- **过度设计**: 本系统不需要有序ID，雪花算法的有序性是多余的

**为什么不需要有序ID？**
- **任务查询**: 通过task_id直接查询，不需要范围查询
- **任务排序**: 通过created_at时间戳排序，不依赖ID顺序

**实现要点**（伪代码）:
```go
// 生成任务ID
func generateTaskID() string {
    // 使用google/uuid库生成UUID v4
    return uuid.New().String()
}
```

---

### 2.3 Redis队列选型：为什么使用List而非Stream？

**决策**: 使用Redis List（RPUSH/BLPOP）实现任务队列

**理由**:
1. **简单性**: List操作简单，易于理解和维护
2. **阻塞拉取**: BLPOP支持阻塞拉取，避免空轮询，节省CPU
3. **FIFO保证**: List天然支持FIFO（先进先出），符合任务队列需求
4. **无需消费者组**: 本系统只有一个Processor服务，无需Stream的消费者组功能

**Redis Stream的问题**:
- **复杂性**: Stream需要管理消费者组、消费者ID，增加复杂度
- **过度设计**: Stream的消息确认、重试机制对本系统是多余的
- **内存占用**: Stream需要维护消费者组元数据，内存占用更高

**为什么不需要消息确认？**
- **幂等性**: Processor服务的任务处理是幂等的，重复处理不会导致问题
- **状态管理**: 任务状态存储在Redis Hash中，即使消息丢失，也可以通过状态恢复

**实现要点**（伪代码）:
```go
// 推入任务队列
func pushTask(taskID, filePath string) error {
    message := map[string]string{
        "task_id": taskID,
        "original_file_path": filePath,
    }
    json, _ := json.Marshal(message)

    // 使用RPUSH推入队列尾部
    return redisClient.RPush("task:pending", json).Err()
}
```

---

### 2.4 任务状态存储：为什么使用Hash而非String？

**决策**: 使用Redis Hash存储任务状态，而非JSON字符串

**理由**:
1. **部分更新**: Hash支持部分字段更新（HSET），无需读取整个对象
2. **原子性**: HSET是原子操作，避免并发更新冲突
3. **内存效率**: Hash的内存占用低于String（Redis内部优化）
4. **查询便利**: 支持HGET查询单个字段，无需反序列化整个对象

**String（JSON）的问题**:
- **全量更新**: 更新任何字段都需要读取、修改、写入整个JSON
- **并发冲突**: 多个服务同时更新会导致数据覆盖
- **性能问题**: 大JSON的序列化/反序列化开销高

**实现要点**（伪代码）:
```go
// 创建任务记录
func createTaskRecord(taskID, filePath string) error {
    fields := map[string]interface{}{
        "task_id": taskID,
        "status": "PENDING",
        "original_file_path": filePath,
        "created_at": time.Now().Unix(),
        "updated_at": time.Now().Unix(),
    }

    // 使用HSET批量设置字段
    return redisClient.HSet("task:"+taskID, fields).Err()
}
```

---

### 2.5 任务TTL策略：为什么使用7天而非永久保存？

**决策**: 任务记录在Redis中保留7天后自动删除

**理由**:
1. **内存管理**: Redis是内存数据库，永久保存会导致内存耗尽
2. **用户体验**: 7天足够用户下载结果文件，超过7天的任务通常已无价值
3. **成本控制**: 减少Redis内存占用，降低运维成本
4. **符合行业惯例**: 大多数视频处理服务的结果保留期为3-7天

**为什么不使用更短的TTL（如1天）？**
- **用户体验**: 用户可能在几天后才下载结果文件，1天太短
- **调试需求**: 开发和运维需要查看历史任务，7天是合理的调试窗口

**为什么不使用更长的TTL（如30天）？**
- **内存成本**: 30天的任务记录会占用大量Redis内存
- **实际需求**: 用户通常在任务完成后立即下载，超过7天的任务很少被访问

**实现要点**（伪代码）:
```go
// 设置任务TTL
func setTaskTTL(taskID string, ttlDays int) error {
    ttlSeconds := ttlDays * 86400

    // 使用EXPIRE设置过期时间
    return redisClient.Expire("task:"+taskID, time.Duration(ttlSeconds)*time.Second).Err()
}
```

---

### 2.6 文件扩展名提取策略：为什么使用filepath.Ext而非字符串分割？

**决策**: 使用`filepath.Ext`提取文件扩展名

**理由**:
1. **标准化**: `filepath.Ext`是Go标准库函数，经过充分测试
2. **边界处理**: 自动处理边界情况（如无扩展名、多个点、隐藏文件）
3. **跨平台**: 支持Windows和Linux的路径格式
4. **可读性**: 代码意图清晰，易于维护

**字符串分割的问题**:
- **边界情况**: 需要手动处理无扩展名、多个点等情况
- **错误风险**: 容易出现off-by-one错误
- **可维护性**: 代码意图不清晰，难以维护

**边界情况处理**:
- `video.mp4` → `.mp4`
- `video.tar.gz` → `.gz`（只取最后一个扩展名）
- `video` → ``（无扩展名）
- `.hidden` → ``（隐藏文件无扩展名）

**实现要点**（伪代码）:
```go
// 提取文件扩展名
func extractExtension(filename string) string {
    ext := filepath.Ext(filename)

    // 如果无扩展名，默认使用.mp4
    if ext == "" {
        return ".mp4"
    }

    return ext
}
```

---

### 2.7 错误处理策略：如何处理文件移动失败、Redis写入失败、队列推入失败？

**决策**: 采用"快速失败 + 资源清理 + 明确错误码"策略

**核心原则**:
1. **快速失败**: 遇到错误立即返回，不进行重试（重试由客户端决定）
2. **资源清理**: 失败时清理已创建的资源（任务目录、Redis记录）
3. **明确错误码**: 使用gRPC标准状态码，便于客户端处理
4. **详细错误信息**: 错误消息包含具体原因，便于排查

**错误分类与处理**:

| 错误类型      | gRPC状态码       | 处理策略                            | 是否清理资源 |
| ------------- | ---------------- | ----------------------------------- | ------------ |
| 参数无效      | INVALID_ARGUMENT | 立即返回，记录WARN日志              | 否           |
| 文件移动失败  | INTERNAL         | 清理任务目录，记录ERROR日志         | 是           |
| Redis连接失败 | UNAVAILABLE      | 清理任务目录，记录ERROR日志         | 是           |
| 任务入队失败  | INTERNAL         | 更新任务状态为FAILED，记录ERROR日志 | 否           |
| 任务不存在    | NOT_FOUND        | 立即返回，记录WARN日志              | 否           |

**资源清理示例**（伪代码）:
```go
// 创建任务逻辑
func createTask(tempPath, filename string) (string, error) {
    taskID := generateTaskID()
    taskDir := ""

    defer func() {
        // 失败时清理任务目录
        if taskDir != "" && err != nil {
            os.RemoveAll(taskDir)
        }
    }()

    // 移动文件
    taskDir = createTaskDir(taskID)
    err := moveFile(tempPath, taskDir+"/original"+ext)
    if err != nil {
        return "", status.Error(codes.Internal, "文件交接失败")
    }

    // 创建任务记录
    err = createTaskRecord(taskID, taskDir+"/original"+ext)
    if err != nil {
        return "", status.Error(codes.Unavailable, "无法连接到状态存储服务")
    }

    return taskID, nil
}
```

## 3. 依赖库清单（及选型原因）

| 依赖库             | 版本要求  | 选型原因                                 |
| ------------------ | --------- | ---------------------------------------- |
| **go-zero**        | >= 1.6.0  | 微服务框架，提供gRPC支持、配置管理、日志 |
| **grpc**           | >= 1.60.0 | 官方gRPC Go实现，用于实现gRPC服务        |
| **protobuf**       | >= 1.31.0 | Protocol Buffers，用于定义gRPC接口       |
| **go-redis/redis** | >= 9.0.0  | Redis客户端，用于任务队列和状态存储      |
| **google/uuid**    | >= 1.6.0  | UUID生成，用于生成任务ID                 |

**为什么选择go-zero？**
1. **gRPC支持**: 内置gRPC服务器，支持.proto文件自动生成代码
2. **配置管理**: 支持YAML配置文件，环境变量覆盖
3. **日志集成**: 内置结构化日志，支持日志级别控制
4. **社区活跃**: GitHub 27k+ stars，问题响应及时

**为什么选择go-redis/redis v9？**
1. **性能优势**: 支持Pipeline和连接池，性能优于v8
2. **API简洁**: 链式调用，代码可读性高
3. **类型安全**: 泛型支持，减少类型转换错误
4. **阻塞操作**: 支持BLPOP等阻塞操作，适合任务队列场景

**为什么选择google/uuid？**
1. **标准化**: 符合RFC 4122标准
2. **唯一性**: UUID v4保证全局唯一性
3. **性能**: 生成速度快（微秒级）
4. **无依赖**: 纯Go实现，无外部依赖

---

## 4. 构建要求说明

> ⚠️ **注意**：根据`design-rules.md`第181-330行的"部署阶段文档约束"规则，完整的Dockerfile将在部署阶段专门撰写。本章仅说明构建要求。

### 4.1 Go版本要求

- **最低版本**: Go 1.21
- **推荐版本**: Go 1.22
- **原因**: go-zero 1.6+要求Go 1.21+，泛型支持需要Go 1.18+

### 4.2 系统依赖

- **protoc**: Protocol Buffers编译器，用于生成.pb.go文件
- **protoc-gen-go**: Go语言的protobuf插件
- **protoc-gen-go-grpc**: Go语言的gRPC插件

### 4.3 环境变量

> 📋 **开发期约束**：以下环境变量的默认值是经过初步评估的合理假设值，开发期间请**严格使用这些默认值**以保证开发一致性。开发或MVP阶段发现问题时，更新文档并同步到所有开发者。

| 环境变量             | 默认值        | 说明                                 |
| -------------------- | ------------- | ------------------------------------ |
| `TASK_GRPC_PORT`     | 50050         | gRPC服务端口                         |
| `LOCAL_STORAGE_PATH` | ./data/videos | 正式视频文件存储路径                 |
| `TEMP_STORAGE_PATH`  | ./data/temp   | 临时文件存储路径                     |
| `REDIS_HOST`         | redis         | Redis主机地址                        |
| `REDIS_PORT`         | 6379          | Redis端口                            |
| `REDIS_PASSWORD`     | 空            | Redis密码（可选）                    |
| `REDIS_DB`           | 0             | Redis数据库编号                      |
| `TASK_TTL_DAYS`      | 7             | 任务记录保留天数                     |
| `TASK_QUEUE_KEY`     | task:pending  | 待处理队列的Redis Key                |
| `LOG_LEVEL`          | info          | 日志级别（debug, info, warn, error） |

### 4.4 运行要求

- **内存**: 最低256MB，推荐512MB（Redis连接池+gRPC连接池）
- **磁盘**: 最低10GB（任务文件存储）
- **CPU**: 最低1核，推荐2核

---

## 5. 测试策略

> ⚠️ **核心理念**：本章说明测试策略和测试覆盖范围，不包含具体测试代码。测试代码将在实现阶段编写。

### 5.1 单元测试策略

**测试目标**: 验证各个模块的独立功能正确性

**测试范围**:

| 模块               | 测试内容                                 | Mock对象    |
| ------------------ | ---------------------------------------- | ----------- |
| **任务ID生成**     | UUID格式正确、唯一性                     | 无          |
| **文件扩展名提取** | 正常扩展名、无扩展名、多个点             | 无          |
| **文件移动逻辑**   | 同文件系统移动、跨文件系统移动、移动失败 | 文件系统    |
| **任务记录创建**   | 字段完整性、TTL设置                      | Redis客户端 |
| **任务队列推入**   | JSON格式正确、推入成功、推入失败         | Redis客户端 |
| **任务状态查询**   | 任务存在、任务不存在                     | Redis客户端 |

**为什么使用Mock？**
- **隔离外部依赖**: 单元测试不应依赖外部服务（Redis、文件系统），使用Mock模拟外部依赖
- **提升测试速度**: Mock对象响应速度快，单元测试可以在秒级完成
- **可重复性**: Mock对象行为可控，测试结果可重复

**Mock工具选择**:
- **gomock**: 官方Mock框架，支持接口Mock
- **testify/mock**: 社区流行的Mock框架，API简洁

---

### 5.2 集成测试策略

**测试目标**: 验证服务与外部依赖（Redis、文件系统）的集成正确性

**测试范围**:

| 测试场景         | 测试内容                                    | 外部依赖        |
| ---------------- | ------------------------------------------- | --------------- |
| **Redis集成**    | 任务记录创建、任务队列推入、任务状态查询    | Redis（Docker） |
| **文件系统集成** | 文件移动、任务目录创建、文件删除            | 本地文件系统    |
| **gRPC集成**     | CreateTask调用、GetTaskStatus调用、错误处理 | gRPC服务器      |

**为什么需要集成测试？**
- **验证Redis操作**: 单元测试无法验证Redis命令的正确性，集成测试可以验证
- **验证文件操作**: 单元测试无法验证文件移动的正确性，集成测试可以验证
- **验证错误处理**: 集成测试可以验证真实错误场景（如Redis连接失败、磁盘空间不足）

**集成测试环境**:
- **Redis**: 使用Docker启动Redis容器，测试结束后自动清理
- **文件系统**: 使用临时目录，测试结束后自动清理

---

### 5.3 端到端测试策略

**测试目标**: 验证完整的gRPC API流程

**测试范围**:

| 测试场景         | 测试内容                              | 验证点                           |
| ---------------- | ------------------------------------- | -------------------------------- |
| **创建任务**     | CreateTask调用                        | 文件移动、任务记录创建、任务入队 |
| **查询任务状态** | GetTaskStatus调用                     | 任务存在、任务不存在             |
| **错误处理**     | 参数无效、文件移动失败、Redis连接失败 | 错误码正确、错误信息清晰         |

**为什么需要端到端测试？**
- **验证完整流程**: 端到端测试覆盖从gRPC请求到响应的完整流程，验证各个模块的集成
- **验证错误处理**: 端到端测试可以验证gRPC错误码映射、错误消息格式
- **验证性能**: 端到端测试可以验证服务的整体性能（延迟、吞吐量）

**端到端测试环境**:
- **gRPC服务**: 启动完整的Task服务
- **Redis**: 使用Docker启动Redis容器
- **文件系统**: 使用临时目录

---

### 5.4 测试覆盖率目标

| 模块             | 目标覆盖率 | 说明                                 |
| ---------------- | ---------- | ------------------------------------ |
| **任务ID生成**   | 95%+       | 核心逻辑简单，易于测试               |
| **文件移动逻辑** | 90%+       | 包含跨文件系统处理，部分场景难以覆盖 |
| **任务记录创建** | 85%+       | 包含Redis交互，部分场景难以覆盖      |
| **任务队列推入** | 85%+       | 包含Redis交互，部分场景难以覆盖      |
| **gRPC Handler** | 80%+       | 包含gRPC请求解析，部分场景难以覆盖   |

**为什么不追求100%覆盖率？**
- **成本收益**: 100%覆盖率需要大量测试代码，成本高，收益低
- **难以覆盖的场景**: 部分错误场景（如磁盘满、Redis宕机）难以在单元测试中模拟
- **合理目标**: 80-95%覆盖率是合理的目标，可以覆盖大部分核心逻辑

---

## 6. 待实现任务清单 (TODO List)

> ⚠️ **说明**：本清单按照实现顺序排列，包含任务ID、描述、预估工时、依赖关系。

### 6.1 基础设施搭建（Phase 1）

| 任务ID   | 任务描述                                    | 预估工时 | 依赖关系 | 优先级 |
| -------- | ------------------------------------------- | -------- | -------- | ------ |
| TASK-001 | 创建项目目录结构，初始化Go模块              | 0.5h     | 无       | P0     |
| TASK-002 | 编写`task.proto`文件，定义gRPC接口          | 2h       | TASK-001 | P0     |
| TASK-003 | 使用`protoc`生成Protobuf和gRPC代码          | 0.5h     | TASK-002 | P0     |
| TASK-004 | 编写`config.go`，加载环境变量和YAML配置     | 1h       | TASK-003 | P0     |
| TASK-005 | 编写`service_context.go`，初始化Redis客户端 | 1.5h     | TASK-004 | P0     |
| TASK-006 | 编写`main.go`，启动gRPC服务器               | 1h       | TASK-005 | P0     |

**Phase 1 总工时**: 6.5小时

---

### 6.2 存储层实现（Phase 2）

| 任务ID   | 任务描述                                          | 预估工时 | 依赖关系          | 优先级 |
| -------- | ------------------------------------------------- | -------- | ----------------- | ------ |
| TASK-007 | 实现`file.go`：文件移动函数（os.Rename + 降级）   | 2h       | TASK-006          | P0     |
| TASK-008 | 实现`file.go`：任务目录创建函数                   | 1h       | TASK-007          | P0     |
| TASK-009 | 实现`file.go`：文件扩展名提取函数                 | 0.5h     | TASK-007          | P0     |
| TASK-010 | 实现`redis.go`：任务记录创建函数（HSET + EXPIRE） | 2h       | TASK-006          | P0     |
| TASK-011 | 实现`redis.go`：任务队列推入函数（RPUSH）         | 1h       | TASK-010          | P0     |
| TASK-012 | 实现`redis.go`：任务状态查询函数（HGETALL）       | 1h       | TASK-010          | P0     |
| TASK-013 | 编写存储层的单元测试（覆盖率 > 90%）              | 4h       | TASK-007~TASK-012 | P0     |

**Phase 2 总工时**: 11.5小时

---

### 6.3 业务逻辑实现（Phase 3）

| 任务ID   | 任务描述                                         | 预估工时 | 依赖关系          | 优先级 |
| -------- | ------------------------------------------------ | -------- | ----------------- | ------ |
| TASK-014 | 实现`create_task_logic.go`：参数校验             | 1h       | TASK-013          | P0     |
| TASK-015 | 实现`create_task_logic.go`：文件交接逻辑         | 2h       | TASK-014          | P0     |
| TASK-016 | 实现`create_task_logic.go`：任务记录创建逻辑     | 1.5h     | TASK-015          | P0     |
| TASK-017 | 实现`create_task_logic.go`：任务入队逻辑         | 1h       | TASK-016          | P0     |
| TASK-018 | 实现`create_task_logic.go`：错误处理和资源清理   | 2h       | TASK-017          | P0     |
| TASK-019 | 实现`get_task_status_logic.go`：任务状态查询逻辑 | 1.5h     | TASK-013          | P0     |
| TASK-020 | 编写业务逻辑的单元测试（Mock Redis和文件系统）   | 4h       | TASK-014~TASK-019 | P0     |

**Phase 3 总工时**: 13小时

---

### 6.4 集成测试与优化（Phase 4）

| 任务ID   | 任务描述                             | 预估工时 | 依赖关系 | 优先级 |
| -------- | ------------------------------------ | -------- | -------- | ------ |
| TASK-021 | 编写集成测试（真实Redis和文件系统）  | 3h       | TASK-020 | P0     |
| TASK-022 | 编写端到端测试（完整gRPC API流程）   | 3h       | TASK-021 | P0     |
| TASK-023 | 性能测试（压力测试、并发测试）       | 2h       | TASK-022 | P1     |
| TASK-024 | 内存泄漏检测（pprof分析）            | 1.5h     | TASK-023 | P1     |
| TASK-025 | 代码审查与优化（代码质量、性能优化） | 2h       | TASK-024 | P1     |
| TASK-026 | 文档完善（代码注释、README）         | 1.5h     | TASK-025 | P1     |

**Phase 4 总工时**: 13小时

---

### 6.5 总工时统计

| Phase   | 描述           | 总工时 | 累计工时 |
| ------- | -------------- | ------ | -------- |
| Phase 1 | 基础设施搭建   | 6.5h   | 6.5h     |
| Phase 2 | 存储层实现     | 11.5h  | 18h      |
| Phase 3 | 业务逻辑实现   | 13h    | 31h      |
| Phase 4 | 集成测试与优化 | 13h    | 44h      |

**总计**: 44小时（约6个工作日，按每天8小时计算）

---

### 6.6 关键里程碑

| 里程碑                   | 完成标志                  | 预计完成时间 |
| ------------------------ | ------------------------- | ------------ |
| **M1: 基础框架搭建完成** | Phase 1完成，服务可启动   | Day 1        |
| **M2: 存储层实现完成**   | Phase 2完成，单元测试通过 | Day 2        |
| **M3: 业务逻辑实现完成** | Phase 3完成，单元测试通过 | Day 4        |
| **M4: 集成测试完成**     | Phase 4完成，所有测试通过 | Day 6        |

---

### 6.7 风险与缓解措施

| 风险                   | 影响 | 概率 | 缓解措施                               |
| ---------------------- | ---- | ---- | -------------------------------------- |
| **跨文件系统移动失败** | 中   | 低   | 实现降级逻辑（io.Copy + os.Remove）    |
| **Redis连接不稳定**    | 高   | 低   | 实现连接池和重试机制，增加健康检查     |
| **磁盘空间不足**       | 高   | 中   | 实现磁盘空间预检（由Gateway负责）      |
| **任务ID冲突**         | 高   | 极低 | UUID v4碰撞概率 < 10^-18，无需特殊处理 |

---

## 7. 与第二层文档的对应关系

本文档严格遵循第二层文档`Task-design.md` v1.5的设计，核心对应关系如下：

| 第二层文档章节            | 第三层文档章节       | 对应关系说明                              |
| ------------------------- | -------------------- | ----------------------------------------- |
| **1. 服务定位与核心职责** | 2.1, 2.3, 2.7        | 文件移动策略、Redis队列选型、错误处理策略 |
| **2. gRPC接口定义**       | 4.2 系统依赖         | protoc、protoc-gen-go、protoc-gen-go-grpc |
| **3. 核心数据结构**       | 2.3, 2.4             | Redis队列选型、任务状态存储               |
| **4. 关键逻辑步骤**       | 2.1~2.7 核心实现决策 | 逻辑步骤的实现决策                        |
| **7. 关键配置项定义**     | 4.3 环境变量         | 环境变量定义与默认值                      |

---

## 8. 文档审查清单

根据`REVIEW-CHECKLIST.md`第107-151行的第三层文档审查清单，本文档已完成以下检查：

- [x] **完整性检查**：包含项目结构、核心实现决策、依赖库清单、构建要求、测试策略、待实现任务清单
- [x] **层次分明检查**：核心实现决策专注于"为什么"，避免大段代码复制粘贴
- [x] **代码片段规则检查**：所有代码片段 ≤20行，优先使用伪代码
- [x] **部署文档约束检查**：未包含完整Dockerfile，明确标注"完整部署文档将在部署阶段专门撰写"
- [x] **准确性检查**：与第二层文档`Task-design.md` v1.5一致
- [x] **一致性检查**：与第一层文档`Base-Design.md` v2.2一致

---

**文档结束**
