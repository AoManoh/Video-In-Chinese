# AIAdaptor 服务实现详细设计（第三层）

**文档版本**: 2.0
**创建日期**: 2025-11-02
**关联文档**:
- 第一层：`notes/server/1st/Base-Design.md` v2.2
- 第二层：`notes/server/2nd/AIAdaptor-design.md` v1.6
- 规范文档：`notes/server/1st/design-rules.md`

---

## 版本历史

- **v2.0 (2025-11-02)**:
  - **重大更新**：根据第三层文档工作清单重新编写
  - 完善核心实现决策与上下文（5 个关键决策点）
  - 新增详细的依赖库选型原因
  - 新增完整的测试策略（单元测试、集成测试、Mock 测试）
  - 新增详细的待实现任务清单
  - 严格遵循 design-rules.md 规范（代码片段 ≤20 行，专注于"为什么"）

---

## 1. 项目结构

```
server/mcp/ai_adaptor/
├── main.go                          # gRPC 服务入口，启动服务器
├── internal/
│   ├── logic/
│   │   ├── asr_logic.go             # ASR 服务逻辑
│   │   ├── polish_logic.go          # 文本润色服务逻辑
│   │   ├── translate_logic.go       # 翻译服务逻辑
│   │   ├── optimize_logic.go        # 译文优化服务逻辑
│   │   └── clone_voice_logic.go     # 声音克隆服务逻辑
│   ├── adapters/
│   │   ├── registry.go              # 适配器注册表
│   │   ├── interface.go             # 适配器接口定义
│   │   ├── asr/                     # ASR 适配器实现
│   │   │   ├── aliyun.go
│   │   │   ├── azure.go
│   │   │   └── google.go
│   │   ├── translation/             # 翻译适配器实现
│   │   │   ├── deepl.go
│   │   │   ├── google.go
│   │   │   └── azure.go
│   │   ├── llm/                     # LLM 适配器实现
│   │   │   ├── openai.go
│   │   │   ├── claude.go
│   │   │   └── gemini.go
│   │   └── voice_cloning/           # 声音克隆适配器实现
│   │       └── aliyun_cosyvoice.go
│   ├── voice_cache/
│   │   └── manager.go               # 音色缓存管理器
│   └── config/
│       ├── redis.go                 # Redis 配置读取
│       └── crypto.go                # API 密钥加密解密
├── proto/
│   ├── aiadaptor.proto              # gRPC 接口定义
│   └── aiadaptor.pb.go              # 自动生成的 Go gRPC 代码
└── tests/
    ├── logic_test.go                # 服务逻辑单元测试
    ├── adapters_test.go             # 适配器单元测试
    └── integration_test.go          # 集成测试
```

**关键文件职责**:
- `main.go`: 服务启动入口，初始化 gRPC 服务器、适配器注册表、音色缓存管理器
- `internal/logic/`: 核心业务逻辑，实现第二层文档定义的关键逻辑步骤
- `internal/adapters/`: 适配器实现，封装厂商特定的 API 调用逻辑
- `internal/voice_cache/`: 音色缓存管理器，负责音色注册、缓存、轮询
- `internal/config/`: 配置管理，从 Redis 读取配置并解密 API 密钥

---

## 2. 核心实现决策与上下文

> ⚠️ **核心理念**：本章专注于解释"为什么这么写"，而不是"写了什么"。代码片段仅用于阐明决策，严格限制在 20 行以内，优先使用伪代码。

### 2.1 适配器模式实现：为什么使用接口 + 注册表模式？

**决策**: 采用接口 + 注册表模式实现适配器管理

**理由**:
1. **解耦业务逻辑与厂商实现**: 业务逻辑只依赖接口，不依赖具体实现，符合依赖倒置原则
2. **支持运行时切换**: 通过 Redis 配置动态选择厂商，无需重启服务
3. **易于扩展**: 新增厂商只需实现接口并注册，无需修改业务逻辑
4. **统一错误处理**: 接口层统一处理错误码映射，适配器只需抛出标准错误

**权衡**:
- **缺点**: 增加了一层抽象，代码复杂度略高
- **缓解**: 通过清晰的接口定义和注册表管理，降低理解成本

**实现要点**（伪代码）:
```go
// 接口定义：业务逻辑只依赖接口，不依赖具体实现
type ASRAdapter interface {
    ASR(audioPath, apiKey, endpoint string) ([]Speaker, error)
}

type AdapterRegistry struct {
    asrAdapters map[string]ASRAdapter  // 运行时动态注册和获取适配器
}

func (r *AdapterRegistry) RegisterASR(name string, adapter ASRAdapter) {
    r.asrAdapters[name] = adapter
}

func (r *AdapterRegistry) GetASR(name string) (ASRAdapter, error) {
    adapter, ok := r.asrAdapters[name]
    if !ok { return nil, errors.New("unsupported provider") }
    return adapter, nil
}
```

---

### 2.2 音色缓存策略：为什么使用 Redis 缓存音色 ID？

**决策**: 使用 Redis Hash 缓存音色 ID，同时在内存中维护二级缓存

**理由**:
1. **避免重复注册**: 音色注册耗时 30-60 秒，缓存后后续请求响应时间降低到秒级
2. **跨实例共享**: 多个 AIAdaptor 实例可以共享音色缓存，避免重复注册
3. **持久化**: Redis 缓存在服务重启后仍然有效，无需重新注册
4. **二级缓存**: 内存缓存减少 Redis 访问，提升性能

**缓存结构**:
- **Redis**: `voice_cache:{speaker_id}` → Hash {voice_id, created_at, reference_audio}
- **内存**: `Map<speaker_id, VoiceInfo>`

**缓存失效处理**:
- **场景 1**: Redis 缓存被清理 → 重新注册音色
- **场景 2**: 内存缓存未命中 → 从 Redis 加载
- **场景 3**: 阿里云音色 ID 失效（404） → 清除缓存，重新注册

**为什么使用二级缓存？**
- **性能优化**: 内存访问比 Redis 访问快 10-100 倍
- **降低 Redis 负载**: 减少 Redis 访问频率，提升系统整体性能

---

### 2.3 音色轮询策略：为什么采用固定间隔轮询而非指数退避？

**决策**: 采用固定间隔轮询（每秒查询一次），超时时间 60 秒

**理由**:
1. **简单可靠**: 固定间隔轮询逻辑简单，易于理解和维护
2. **快速响应**: 音色注册通常在 10-30 秒内完成，1 秒间隔可以快速检测到状态变化
3. **避免过度等待**: 指数退避可能导致状态变化后延迟检测，影响用户体验
4. **API 限流友好**: 阿里云 API 限流通常以分钟为单位，1 秒间隔不会触发限流

**权衡**:
- **缺点**: 固定间隔可能导致不必要的 API 调用（如果音色注册很快完成）
- **缓解**: 60 秒超时时间足够覆盖 99% 的场景，超时后返回错误

**为什么不使用 WebSocket 或长轮询？**
- **API 限制**: 阿里云 CosyVoice API 不支持 WebSocket 或长轮询
- **复杂度**: 固定间隔轮询实现简单，满足需求

---

### 2.4 API 密钥解密策略：为什么每次调用都从 Redis 读取并解密？

**决策**: 每次 AI 服务调用都从 Redis 读取加密的 API 密钥并解密

**理由**:
1. **安全性**: API 密钥不在内存中长期驻留，降低泄露风险
2. **动态更新**: 用户更新 API 密钥后立即生效，无需重启服务
3. **审计友好**: 每次读取都有日志记录，便于审计和排查问题
4. **符合最佳实践**: 敏感信息不应在内存中缓存

**权衡**:
- **缺点**: 每次调用都需要 Redis 访问和解密操作，增加延迟（约 1-5ms）
- **缓解**: Redis 访问和 AES-256-GCM 解密都是毫秒级操作，对整体性能影响可忽略

**为什么不缓存解密后的 API 密钥？**
- **安全风险**: 解密后的 API 密钥在内存中缓存，增加泄露风险
- **动态更新**: 缓存后用户更新 API 密钥需要手动刷新缓存，增加复杂度

---

### 2.5 错误处理策略：如何处理 API 调用失败、音色注册失败、缓存失效？

**决策**: 采用"快速失败 + 自动恢复 + 降级策略"组合

**核心原则**:
1. **快速失败**: 遇到不可恢复的错误（如 API 密钥无效）立即返回，不进行重试
2. **自动恢复**: 遇到可恢复的错误（如音色失效）自动清除缓存并重试
3. **降级策略**: 可选功能（如文本润色）失败时返回原文，不影响核心流程
4. **明确错误码**: 使用 gRPC 标准错误码，便于调用方处理

**错误分类与处理**:

| 错误类型                 | gRPC 错误码       | 处理策略                  | 是否重试   |
| ------------------------ | ----------------- | ------------------------- | ---------- |
| API 密钥无效（401/403）  | UNAUTHENTICATED   | 立即返回，记录 ERROR 日志 | 否         |
| API 配额不足（429）      | PERMISSION_DENIED | 立即返回，记录 ERROR 日志 | 否         |
| 外部 API 服务错误（5xx） | INTERNAL          | 重试 2 次，间隔 2 秒      | 是         |
| 音色失效（404）          | 自动恢复          | 清除缓存，重新注册音色    | 是（自动） |
| Redis 连接失败           | UNAVAILABLE       | 重试 3 次，间隔 1 秒      | 是         |
| 参数无效                 | INVALID_ARGUMENT  | 立即返回，记录 WARN 日志  | 否         |

**降级策略**:
- **文本润色**: `polishing_enabled=false` 或润色失败 → 返回原文
- **译文优化**: `optimization_enabled=false` 或优化失败 → 返回原文
- **音色失效**: 自动清除缓存并重新注册，对调用方透明

**为什么音色失效采用自动恢复而非返回错误？**
- **用户体验**: 自动恢复对调用方透明，无需 Processor 服务处理
- **常见场景**: 阿里云音色 ID 可能因为过期或清理而失效，自动恢复是合理的默认行为

---

## 3. 依赖库清单（及选型原因）

| 依赖库             | 版本要求  | 选型原因                                           |
| ------------------ | --------- | -------------------------------------------------- |
| **go-zero**        | >= 1.6.0  | 微服务框架，提供 gRPC 服务支持、配置管理、日志管理 |
| **grpc**           | >= 1.60.0 | 官方 gRPC Go 实现，稳定性高，社区活跃              |
| **go-redis/redis** | >= 9.0.0  | Redis 客户端，支持 Pipeline、事务、Lua 脚本        |
| **crypto/aes**     | 标准库    | AES-256-GCM 加密解密，安全性高，性能好             |

**为什么选择 go-zero？**
1. **微服务支持**: 内置 gRPC 服务支持，无需额外配置
2. **配置管理**: 支持环境变量、配置文件、远程配置
3. **日志管理**: 结构化日志，支持日志级别、日志轮转
4. **社区活跃**: GitHub 27k+ stars，问题响应及时

**为什么选择 go-redis/redis v9？**
1. **性能优势**: 支持 Pipeline 和连接池，性能优于 v8
2. **API 简洁**: 链式调用，代码可读性高
3. **类型安全**: 泛型支持，减少类型转换错误

**为什么使用标准库 crypto/aes？**
1. **安全性**: AES-256-GCM 是 NIST 推荐的加密算法
2. **性能**: 标准库实现经过优化，性能优于第三方库
3. **无依赖**: 减少外部依赖，降低安全风险

---

## 4. 构建要求说明

> ⚠️ **注意**：根据 `design-rules.md` 第 181-330 行的"部署阶段文档约束"规则，完整的 Dockerfile 将在部署阶段专门撰写。本章仅说明构建要求。

### 4.1 Go 版本要求

- **最低版本**: Go 1.21
- **推荐版本**: Go 1.22
- **原因**: go-zero 1.6+ 要求 Go 1.21+，泛型支持需要 Go 1.18+

### 4.2 系统依赖

无特殊系统依赖，标准 Linux 环境即可。

### 4.3 环境变量

> 📋 **开发期约束**：以下环境变量的默认值是经过初步评估的合理值，开发期间请**严格使用这些默认值**以保证开发一致性。MVP完成后，将通过实际性能测试调整这些值，并将测试结果和优化后的值同步回本文档。

| 环境变量                        | 默认值 | 说明                                                |
| ------------------------------- | ------ | --------------------------------------------------- |
| `AI_ADAPTOR_GRPC_PORT`          | 50053  | gRPC 服务端口                                       |
| `API_KEY_ENCRYPTION_SECRET`     | 无     | **必填**，API 密钥加密密钥（32 字节十六进制字符串） |
| `REDIS_HOST`                    | redis  | Redis 主机地址                                      |
| `REDIS_PORT`                    | 6379   | Redis 端口                                          |
| `REDIS_PASSWORD`                | 空     | Redis 密码（可选）                                  |
| `REDIS_DB`                      | 0      | Redis 数据库编号                                    |
| `VOICE_CACHE_TTL`               | 0      | 音色缓存过期时间（秒，0 表示不过期）                |
| `VOICE_REGISTER_TIMEOUT`        | 60     | 音色注册超时时间（秒）                              |
| `VOICE_REGISTER_RETRY`          | 3      | 音色注册失败重试次数                                |
| `VOICE_REGISTER_RETRY_INTERVAL` | 5      | 音色注册重试间隔（秒）                              |
| `API_CALL_TIMEOUT`              | 30     | 外部 API 调用超时时间（秒）                         |
| `API_CALL_RETRY`                | 2      | 外部 API 调用失败重试次数                           |
| `API_CALL_RETRY_INTERVAL`       | 2      | 外部 API 调用重试间隔（秒）                         |
| `LOG_LEVEL`                     | info   | 日志级别（debug, info, warn, error）                |

### 4.4 运行要求

- **内存**: 最低 512MB，推荐 1GB（适配器实例 + Redis 连接池）
- **磁盘**: 最低 100MB（日志文件）
- **CPU**: 最低 1 核，推荐 2 核

---

## 5. 测试策略

> ⚠️ **核心理念**：本章说明测试策略和测试覆盖范围，不包含具体测试代码。测试代码将在实现阶段编写。

### 5.1 单元测试策略

**测试目标**: 验证各个模块的独立功能正确性

**测试范围**:

| 模块               | 测试内容                               | Mock 对象                   |
| ------------------ | -------------------------------------- | --------------------------- |
| **适配器注册表**   | 注册、获取、不存在的厂商               | 无                          |
| **音色缓存管理器** | 缓存读写、失效处理、二级缓存           | Redis 客户端                |
| **API 密钥解密**   | 解密成功、解密失败、密钥格式错误       | 无                          |
| **ASR 适配器**     | API 调用成功、API 调用失败、错误码映射 | HTTP 客户端                 |
| **翻译适配器**     | API 调用成功、API 调用失败、错误码映射 | HTTP 客户端                 |
| **LLM 适配器**     | API 调用成功、API 调用失败、错误码映射 | HTTP 客户端                 |
| **声音克隆适配器** | 音色注册、音色合成、轮询超时           | HTTP 客户端、音色缓存管理器 |

**为什么使用 Mock？**
- **隔离外部依赖**: 单元测试不应依赖外部服务（Redis、HTTP API），使用 Mock 模拟外部依赖
- **提升测试速度**: Mock 对象响应速度快，单元测试可以在秒级完成
- **可重复性**: Mock 对象行为可控，测试结果可重复

**Mock 工具选择**:
- **gomock**: 官方 Mock 框架，支持接口 Mock
- **testify/mock**: 社区流行的 Mock 框架，API 简洁

---

### 5.2 集成测试策略

**测试目标**: 验证服务与外部依赖（Redis、外部 API）的集成正确性

**测试范围**:

| 测试场景         | 测试内容                                 | 外部依赖                         |
| ---------------- | ---------------------------------------- | -------------------------------- |
| **Redis 集成**   | 音色缓存读写、缓存失效、连接失败         | Redis（Docker）                  |
| **ASR 集成**     | 调用真实 ASR API，验证响应格式           | 阿里云 ASR API（测试账号）       |
| **翻译集成**     | 调用真实翻译 API，验证响应格式           | DeepL API（测试账号）            |
| **LLM 集成**     | 调用真实 LLM API，验证响应格式           | OpenAI API（测试账号）           |
| **声音克隆集成** | 调用真实声音克隆 API，验证音色注册和合成 | 阿里云 CosyVoice API（测试账号） |

**为什么需要集成测试？**
- **验证 API 兼容性**: 外部 API 可能更新，集成测试可以及时发现兼容性问题
- **验证错误处理**: 单元测试无法覆盖所有外部 API 错误场景，集成测试可以验证错误处理逻辑
- **验证性能**: 集成测试可以验证外部 API 调用的性能（延迟、超时）

**集成测试环境**:
- **Redis**: 使用 Docker 启动 Redis 容器，测试结束后自动清理
- **外部 API**: 使用测试账号，避免影响生产环境

---

### 5.3 端到端测试策略

**测试目标**: 验证完整的 gRPC 服务流程

**测试范围**:

| 测试场景         | 测试内容                                | 验证点                       |
| ---------------- | --------------------------------------- | ---------------------------- |
| **ASR 服务**     | 调用 ASR gRPC 接口，验证返回结果        | 说话人分离、时间戳、文本内容 |
| **文本润色服务** | 调用 Polish gRPC 接口，验证返回结果     | 润色后的文本、降级策略       |
| **翻译服务**     | 调用 Translate gRPC 接口，验证返回结果  | 翻译后的文本、语言检测       |
| **译文优化服务** | 调用 Optimize gRPC 接口，验证返回结果   | 优化后的文本、降级策略       |
| **声音克隆服务** | 调用 CloneVoice gRPC 接口，验证返回结果 | 音频文件路径、音色缓存       |

**为什么需要端到端测试？**
- **验证完整流程**: 端到端测试覆盖从 gRPC 请求到响应的完整流程，验证各个模块的集成
- **验证错误处理**: 端到端测试可以验证 gRPC 错误码映射、错误消息格式
- **验证性能**: 端到端测试可以验证服务的整体性能（延迟、吞吐量）

**端到端测试环境**:
- **gRPC 服务**: 启动完整的 AIAdaptor 服务
- **Redis**: 使用 Docker 启动 Redis 容器
- **外部 API**: 使用 Mock 服务器或测试账号

---

### 5.4 测试覆盖率目标

| 模块               | 目标覆盖率 | 说明                                |
| ------------------ | ---------- | ----------------------------------- |
| **适配器注册表**   | 90%+       | 核心逻辑简单，易于测试              |
| **音色缓存管理器** | 85%+       | 包含 Redis 交互，部分场景难以覆盖   |
| **API 密钥解密**   | 95%+       | 核心逻辑简单，易于测试              |
| **适配器实现**     | 80%+       | 包含外部 API 调用，部分场景难以覆盖 |
| **服务逻辑**       | 85%+       | 核心业务逻辑，需要高覆盖率          |

**为什么不追求 100% 覆盖率？**
- **成本收益**: 100% 覆盖率需要大量测试代码，成本高，收益低
- **难以覆盖的场景**: 部分错误场景（如网络超时、Redis 连接失败）难以在单元测试中模拟
- **合理目标**: 80-95% 覆盖率是合理的目标，可以覆盖大部分核心逻辑

---

## 6. 待实现任务清单

> ⚠️ **核心理念**：本章列出所有待实现的任务，按优先级排序，便于开发团队跟踪进度。

### 6.1 核心功能实现（P0 - 必须完成）

| 任务 ID      | 任务描述                                                      | 预估工时 | 依赖                                   |
| ------------ | ------------------------------------------------------------- | -------- | -------------------------------------- |
| **CORE-001** | 实现适配器注册表（`internal/adapters/registry.go`）           | 4h       | 无                                     |
| **CORE-002** | 实现适配器接口定义（`internal/adapters/interface.go`）        | 2h       | 无                                     |
| **CORE-003** | 实现音色缓存管理器（`internal/voice_cache/manager.go`）       | 8h       | CORE-001                               |
| **CORE-004** | 实现 API 密钥解密（`internal/config/crypto.go`）              | 4h       | 无                                     |
| **CORE-005** | 实现 Redis 配置读取（`internal/config/redis.go`）             | 4h       | 无                                     |
| **CORE-006** | 实现 ASR 服务逻辑（`internal/logic/asr_logic.go`）            | 6h       | CORE-001, CORE-004, CORE-005           |
| **CORE-007** | 实现文本润色服务逻辑（`internal/logic/polish_logic.go`）      | 6h       | CORE-001, CORE-004, CORE-005           |
| **CORE-008** | 实现翻译服务逻辑（`internal/logic/translate_logic.go`）       | 6h       | CORE-001, CORE-004, CORE-005           |
| **CORE-009** | 实现译文优化服务逻辑（`internal/logic/optimize_logic.go`）    | 6h       | CORE-001, CORE-004, CORE-005           |
| **CORE-010** | 实现声音克隆服务逻辑（`internal/logic/clone_voice_logic.go`） | 8h       | CORE-001, CORE-003, CORE-004, CORE-005 |
| **CORE-011** | 实现 gRPC 服务入口（`main.go`）                               | 4h       | CORE-006 ~ CORE-010                    |

**总计**: 58 小时（约 7.25 个工作日）

---

### 6.2 适配器实现（P0 - 必须完成）

| 任务 ID         | 任务描述                                                                             | 预估工时 | 依赖               |
| --------------- | ------------------------------------------------------------------------------------ | -------- | ------------------ |
| **ADAPTER-001** | 实现阿里云 ASR 适配器（`internal/adapters/asr/aliyun.go`）                           | 6h       | CORE-002           |
| **ADAPTER-002** | 实现 Azure ASR 适配器（`internal/adapters/asr/azure.go`）                            | 6h       | CORE-002           |
| **ADAPTER-003** | 实现 Google ASR 适配器（`internal/adapters/asr/google.go`）                          | 6h       | CORE-002           |
| **ADAPTER-004** | 实现 DeepL 翻译适配器（`internal/adapters/translation/deepl.go`）                    | 6h       | CORE-002           |
| **ADAPTER-005** | 实现 Google 翻译适配器（`internal/adapters/translation/google.go`）                  | 6h       | CORE-002           |
| **ADAPTER-006** | 实现 Azure 翻译适配器（`internal/adapters/translation/azure.go`）                    | 6h       | CORE-002           |
| **ADAPTER-007** | 实现 OpenAI LLM 适配器（`internal/adapters/llm/openai.go`）                          | 6h       | CORE-002           |
| **ADAPTER-008** | 实现 Claude LLM 适配器（`internal/adapters/llm/claude.go`）                          | 6h       | CORE-002           |
| **ADAPTER-009** | 实现 Gemini LLM 适配器（`internal/adapters/llm/gemini.go`）                          | 6h       | CORE-002           |
| **ADAPTER-010** | 实现阿里云 CosyVoice 适配器（`internal/adapters/voice_cloning/aliyun_cosyvoice.go`） | 12h      | CORE-002, CORE-003 |

**总计**: 66 小时（约 8.25 个工作日）

---

### 6.3 测试实现（P1 - 高优先级）

| 任务 ID      | 任务描述                   | 预估工时 | 依赖                      |
| ------------ | -------------------------- | -------- | ------------------------- |
| **TEST-001** | 实现适配器注册表单元测试   | 2h       | CORE-001                  |
| **TEST-002** | 实现音色缓存管理器单元测试 | 4h       | CORE-003                  |
| **TEST-003** | 实现 API 密钥解密单元测试  | 2h       | CORE-004                  |
| **TEST-004** | 实现 ASR 适配器单元测试    | 6h       | ADAPTER-001 ~ ADAPTER-003 |
| **TEST-005** | 实现翻译适配器单元测试     | 6h       | ADAPTER-004 ~ ADAPTER-006 |
| **TEST-006** | 实现 LLM 适配器单元测试    | 6h       | ADAPTER-007 ~ ADAPTER-009 |
| **TEST-007** | 实现声音克隆适配器单元测试 | 4h       | ADAPTER-010               |
| **TEST-008** | 实现服务逻辑单元测试       | 8h       | CORE-006 ~ CORE-010       |
| **TEST-009** | 实现 Redis 集成测试        | 4h       | CORE-003, CORE-005        |
| **TEST-010** | 实现外部 API 集成测试      | 8h       | ADAPTER-001 ~ ADAPTER-010 |
| **TEST-011** | 实现端到端测试             | 8h       | CORE-011                  |

**总计**: 58 小时（约 7.25 个工作日）

---

### 6.4 文档与部署（P2 - 中优先级）

| 任务 ID        | 任务描述                                       | 预估工时 | 依赖       |
| -------------- | ---------------------------------------------- | -------- | ---------- |
| **DOC-001**    | 编写 API 文档（gRPC 接口说明）                 | 4h       | CORE-011   |
| **DOC-002**    | 编写部署文档（Dockerfile、docker-compose.yml） | 4h       | CORE-011   |
| **DOC-003**    | 编写运维文档（监控、日志、故障排查）           | 4h       | CORE-011   |
| **DEPLOY-001** | 编写 Dockerfile                                | 2h       | CORE-011   |
| **DEPLOY-002** | 编写 docker-compose.yml                        | 2h       | DEPLOY-001 |
| **DEPLOY-003** | 配置 CI/CD 流程（GitHub Actions）              | 4h       | TEST-011   |

**总计**: 20 小时（约 2.5 个工作日）

---

### 6.5 优化与扩展（P3 - 低优先级）

| 任务 ID     | 任务描述                                    | 预估工时 | 依赖                |
| ----------- | ------------------------------------------- | -------- | ------------------- |
| **OPT-001** | 实现音色缓存预热（启动时加载常用音色）      | 4h       | CORE-003            |
| **OPT-002** | 实现 API 调用限流（防止超出配额）           | 4h       | CORE-006 ~ CORE-010 |
| **OPT-003** | 实现 Prometheus 监控指标                    | 4h       | CORE-011            |
| **OPT-004** | 实现分布式追踪（OpenTelemetry）             | 6h       | CORE-011            |
| **EXT-001** | 支持更多 ASR 厂商（AWS Transcribe、讯飞等） | 6h       | CORE-002            |
| **EXT-002** | 支持更多翻译厂商（百度翻译、腾讯翻译等）    | 6h       | CORE-002            |
| **EXT-003** | 支持更多 LLM 厂商（文心一言、通义千问等）   | 6h       | CORE-002            |

**总计**: 36 小时（约 4.5 个工作日）

---

### 6.6 任务优先级说明

**P0（必须完成）**: 核心功能和适配器实现，是服务正常运行的基础
**P1（高优先级）**: 测试实现，保证代码质量和稳定性
**P2（中优先级）**: 文档和部署，便于团队协作和运维
**P3（低优先级）**: 优化和扩展，提升性能和功能丰富度

**总工时估算**: 238 小时（约 30 个工作日，1.5 个月）

---

## 7. 风险与缓解措施

| 风险               | 影响 | 概率 | 缓解措施                                     |
| ------------------ | ---- | ---- | -------------------------------------------- |
| **外部 API 变更**  | 高   | 中   | 定期运行集成测试，及时发现 API 变更          |
| **音色注册超时**   | 中   | 中   | 增加重试机制，记录详细日志便于排查           |
| **Redis 连接失败** | 高   | 低   | 实现重试机制，降级到无缓存模式               |
| **API 密钥泄露**   | 高   | 低   | 使用 AES-256-GCM 加密，定期轮换密钥          |
| **性能瓶颈**       | 中   | 中   | 实现二级缓存，优化 Redis 访问                |
| **依赖库漏洞**     | 中   | 中   | 定期更新依赖库，使用 Dependabot 自动检测漏洞 |

---

## 8. 下一步行动

1. **评审本文档**: 与团队成员评审本文档，确认设计决策和任务清单
2. **创建任务看板**: 在项目管理工具（如 Jira、Trello）中创建任务看板，跟踪进度
3. **开始实现**: 按照任务清单优先级，开始实现核心功能
4. **定期同步**: 每周同步进度，及时调整任务优先级和工时估算

---

**文档结束**

